
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import {
  Menubar,
  MenubarContent,
  MenubarItem,
  MenubarMenu,
  MenubarSeparator,
  MenubarSub,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarTrigger,
} from "@/components/ui/menubar"
import dynamic from 'next/dynamic';
import type { MapRef } from '@/components/Map';
import ModelingToolbar from '@/components/ModelingToolbar';
import ProjectDialog from '@/components/ProjectDialog';
import type { ProjectData } from '@/components/ProjectDialog';
import { useToast } from '@/hooks/use-toast';
import StatusDialog from '@/components/StatusDialog';
import NodesDialog from '@/components/NodesDialog';
import PipesDialog from '@/components/PipesDialog';
import type { Node, Pipe } from '@/types/hydro';
import type { LatLng, LatLngExpression } from 'leaflet';
import { getElevation } from '../app/actions';
import { saveAs } from 'file-saver';
import SaveAsDialog from './SaveAsDialog';
import ScopesDialog from './ScopesDialog';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from './ui/alert-dialog';
import { processKmlFile } from '@/lib/kml-importer';
import CsvImportDialog from './CsvImportDialog';
import Papa from 'papaparse';
import CsvExportDialog from './CsvExportDialog';
import JSZip from 'jszip';
import { generateKml } from '@/lib/kml-generator';
import MeshControlCard from './MeshControlCard';
import type { MeshParams } from './MeshControlCard';
import MeasureControlCard from './MeasureControlCard';
import type { MeasureUnit } from './MeasureControlCard';


const MapComponent = dynamic(() => import('@/components/Map'), {
  ssr: false,
});

type DrawingMode = 'node' | 'pipe' | 'reservoir' | 'valve' | 'pump' | 'tank' | 'wtp' | 'well' | 'intake' | 'vertex' | 'dual' | 'mesh' | 'delete-component' | 'measure' | 'delete-selection' | 'clean' | 'purge' | 'renumber' | 'move' | 'viewer' | 'undo';

export type HydroModel = {
  nodes: Node[];
  pipes: Pipe[];
};

type MeshState = {
    status: 'configuring' | 'settingStart' | 'settingEnd';
    params: MeshParams;
    startPoint: LatLng | null;
}

type MeasureState = {
    status: 'idle' | 'measuring';
    startPoint: LatLng | null;
    distance: number | null;
    unit: MeasureUnit;
}


const initialModel: HydroModel = { nodes: [], pipes: [] };


export default function Home() {
  const mapRef = useRef<MapRef>(null);
  const importKmlInputRef = useRef<HTMLInputElement>(null);
  const openProjectFileInputRef = useRef<HTMLInputElement>(null);
  const [showModelingToolbar, setShowModelingToolbar] = useState(false);
  const [isProjectDialogOpen, setIsProjectDialogOpen] = useState(false);
  const [isStatusDialogOpen, setIsStatusDialogOpen] = useState(false);
  const [isScopesDialogOpen, setIsScopesDialogOpen] = useState(false);
  const [isNodesDialogOpen, setIsNodesDialogOpen] = useState(false);
  const [isPipesDialogOpen, setIsPipesDialogOpen] = useState(false);
  const [isSaveAsDialogOpen, setIsSaveAsDialogOpen] = useState(false);
  const [isCleanConfirmDialogOpen, setIsCleanConfirmDialogOpen] = useState(false);
  const [isRenumberConfirmDialogOpen, setIsRenumberConfirmDialogOpen] = useState(false);
  const [isPurgeConfirmDialogOpen, setIsPurgeConfirmDialogOpen] = useState(false);
  const [isCsvImportDialogOpen, setIsCsvImportDialogOpen] = useState(false);
  const [isCsvExportDialogOpen, setIsCsvExportDialogOpen] = useState(false);
  const [isExitConfirmDialogOpen, setIsExitConfirmDialogOpen] = useState(false);

  const [projectData, setProjectData] = useState<ProjectData | null>(null);
  const [drawingMode, setDrawingMode] = useState<DrawingMode | null>(null);
  const [drawingPipeState, setDrawingPipeState] = useState<{ startNode: Node | null }>({ startNode: null });
  const [hideNodeTooltips, setHideNodeTooltips] = useState(false);

  const [meshState, setMeshState] = useState<MeshState>({
    status: 'configuring',
    params: { numVertical: 7, numHorizontal: 8, distance: 50 },
    startPoint: null,
  });

  const [measureState, setMeasureState] = useState<MeasureState>({
    status: 'idle',
    startPoint: null,
    distance: null,
    unit: 'm'
  });
  
  const { toast } = useToast();

  const [mapCenter, setMapCenter] = useState<LatLngExpression>([-12.046374, -77.042793]);
  const [mapZoom, setMapZoom] = useState<number>(13);

  const [model, setModel] = useState<HydroModel>(initialModel);
  const [history, setHistory] = useState<HydroModel[]>([initialModel]);
  const [historyIndex, setHistoryIndex] = useState(0);

  const { nodes, pipes } = model;
  
  const updateModel = useCallback((modelUpdater: (current: HydroModel) => HydroModel) => {
    setModel(prevModel => {
        const newModel = modelUpdater(prevModel);
        const newHistoryState = [...history.slice(0, historyIndex + 1), newModel];
        setHistory(newHistoryState);
        setHistoryIndex(newHistoryState.length - 1);
        return newModel;
    });
  }, [history, historyIndex]);

  useEffect(() => {
    try {
      const savedData = localStorage.getItem('hydrobim-project-data');
      if (savedData) {
        const parsedData = JSON.parse(savedData);
        if (parsedData.project && parsedData.model) {
          setProjectData(parsedData.project);
          
          const loadedModel = parsedData.model;
          
          setModel(loadedModel);
          setHistory([loadedModel]);
          setHistoryIndex(0);

          if (parsedData.project.latitud && parsedData.project.longitud) {
            const lat = parseFloat(parsedData.project.latitud);
            const lng = parseFloat(parsedData.project.longitud);
            if (!isNaN(lat) && !isNaN(lng)) {
              setMapCenter([lat, lng]);
              setMapZoom(15);
            }
          }
          
          if(loadedModel && (loadedModel.nodes.length > 0 || loadedModel.pipes.length > 0)) {
            setTimeout(() => {
                toast({
                  title: "Proyecto Cargado",
                  description: `Se ha cargado el proyecto "${parsedData.project.nombre}" desde la sesión anterior.`,
                });
            }, 100);
          }
        }
      } else {
        setModel(initialModel);
        setHistory([initialModel]);
        setHistoryIndex(0);
      }
    } catch (error) {
      console.error("Failed to load or parse project data from localStorage", error);
      setModel(initialModel);
      setHistory([initialModel]);
      setHistoryIndex(0);
      setTimeout(() => {
          toast({
            title: "Error al cargar",
            description: "No se pudo cargar el proyecto guardado. Puede estar corrupto.",
            variant: "destructive",
          });
      }, 100);
    }
  }, [toast]);

  const cancelDrawing = useCallback(() => {
    if (drawingPipeState.startNode) {
      mapRef.current?.highlightNode(drawingPipeState.startNode.id, false);
    }
    setDrawingPipeState({ startNode: null });
    setDrawingMode(null);
    mapRef.current?.stopGuideLine();

    if(drawingMode === 'mesh') {
        setMeshState({
            status: 'configuring',
            params: { numVertical: 7, numHorizontal: 8, distance: 50 },
            startPoint: null,
        });
    }
    if (drawingMode === 'measure') {
        handleMeasureExit();
    }

  }, [drawingMode, drawingPipeState.startNode]);

  const resetPipeDrawing = () => {
    if (drawingPipeState.startNode) {
        mapRef.current?.highlightNode(drawingPipeState.startNode.id, false);
        setDrawingPipeState({ startNode: null });
        mapRef.current?.stopGuideLine();
        toast({
            title: "Dibujo de Tubería Reiniciado",
            description: "Seleccione un nuevo nudo de inicio.",
        });
    }
  }

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        if(drawingMode) {
            cancelDrawing();
            toast({
                title: "Modelado Cancelado",
                description: "Se ha salido del modo de dibujo.",
            });
        }
      }
      if (event.key === 'Enter') {
          if ((drawingMode === 'pipe' || drawingMode === 'dual') && drawingPipeState.startNode) {
              resetPipeDrawing();
          }
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [drawingMode, drawingPipeState.startNode, cancelDrawing]);

  const setMapLayer = (layer: 'streets' | 'topo' | 'satellite' | 'neutral') => {
    mapRef.current?.setLayer(layer);
  };

  const toggleModelingToolbar = () => {
    setShowModelingToolbar(prevState => !prevState);
  };
  
  const handleOpenProjectDialog = () => {
    setIsProjectDialogOpen(true);
  };

  const handleClean = () => {
    updateModel(() => initialModel);
    localStorage.removeItem('hydrobim-project-data');
    toast({
        title: "Lienzo Limpiado",
        description: "Se han borrado todos los nudos y tuberías del modelo.",
    });
  };

  const handleNewProject = useCallback(() => {
    setProjectData(null);
    updateModel(() => initialModel);
    
    const defaultCenter: LatLngExpression = [-12.046374, -77.042793];
    setMapCenter(defaultCenter);
    setMapZoom(13);
    mapRef.current?.setView(defaultCenter, 13);
    
    setIsProjectDialogOpen(true);
    
    setTimeout(() => {
      toast({
        title: "Nuevo Proyecto Iniciado",
        description: "Introduce los datos para tu nuevo proyecto. El lienzo ha sido limpiado.",
      });
    }, 100);
  }, [updateModel, toast]);
  
  const createNewPipe = (startNode: Node, endNode: Node, currentPipes: Pipe[]): Pipe => {
      const startLatLng = { lat: startNode.latitud, lng: startNode.longitud };
      const endLatLng = { lat: endNode.latitud, lng: endNode.longitud };
      const R = 6371e3; // metres
      const φ1 = startLatLng.lat * Math.PI/180;
      const φ2 = endLatLng.lat * Math.PI/180;
      const Δφ = (endLatLng.lat-startLatLng.lat) * Math.PI/180;
      const Δλ = (endLatLng.lng-startLatLng.lng) * Math.PI/180;
      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      const length = R * c;

      const nextPipeNumber = (currentPipes.length > 0 ? Math.max(...currentPipes.map(p => parseInt(p.id.substring(2)) || 0)) : 0) + 1;
      const newPipeId = `T-${nextPipeNumber}`;
      
      const newPipe: Pipe = {
        id: newPipeId,
        startNodeId: startNode.id,
        endNodeId: endNode.id,
        length: length,
        type: 'distribution',
      };

      toast({
        title: "Tubería Creada",
        description: `Se ha creado la tubería ${newPipe.id} entre ${startNode.id} y ${endNode.id} con una longitud de ${length.toFixed(2)}m.`
      });

      return newPipe;
  };
  
 const generateMesh = async (startPoint: LatLng, endPoint: LatLng, params: MeshParams, currentModel: HydroModel) => {
    toast({ title: "Generando Malla...", description: "Por favor espere. Este proceso puede tardar." });
    
    const { numHorizontal, numVertical, distance } = params;

    if (numHorizontal < 1 || numVertical < 1) {
        toast({title: "Parámetros de Malla Inválidos", description: "El número de ejes debe ser al menos 1.", variant: "destructive"});
        return;
    }

    const newNodes: Node[] = [];
    const newPipes: Pipe[] = [];
    
    // Create a 2D array to store the generated nodes
    const nodeGrid: (Node | null)[][] = Array.from({ length: numVertical }, () => Array(numHorizontal).fill(null));

    const latDegPerMeter = 1 / 111132.954;
    const lonDegPerMeterAtLat = (lat: number) => 1 / (111320 * Math.cos(lat * Math.PI / 180));

    let nextNodeIdCounter = (currentModel.nodes.length > 0 ? Math.max(...currentModel.nodes.map(n => parseInt(n.id.substring(1)) || 0)) : 0) + 1;
    
    const deltaLat = endPoint.lat - startPoint.lat;
    const deltaLng = endPoint.lng - startPoint.lng;
    const angle = Math.atan2(deltaLng, deltaLat);

    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);

    for (let i = 0; i < numVertical; i++) {
        for (let j = 0; j < numHorizontal; j++) {
            
            const localX = j * distance;
            const localY = i * distance;
            
            const rotatedX = localX * cosAngle - localY * sinAngle;
            const rotatedY = localX * sinAngle + localY * cosAngle;

            const newLat = startPoint.lat + rotatedY * latDegPerMeter;
            const newLng = startPoint.lng + rotatedX * lonDegPerMeterAtLat(startPoint.lat);
            
            const elevation = await getElevation(newLat, newLng);
            
            const newNode: Node = {
                id: `N${nextNodeIdCounter++}`,
                latitud: newLat,
                longitud: newLng,
                cotaTerreno: elevation,
                type: 'node'
            };
            newNodes.push(newNode);
            nodeGrid[i][j] = newNode;
        }
    }
    
    let nextPipeIdCounter = (currentModel.pipes.length > 0 ? Math.max(...currentModel.pipes.map(p => parseInt(p.id.substring(2)) || 0)) : 0) + 1;

    // Create horizontal pipes
    for (let i = 0; i < numVertical; i++) {
        for (let j = 0; j < numHorizontal - 1; j++) {
            const startNode = nodeGrid[i][j];
            const endNode = nodeGrid[i][j+1];
            if(startNode && endNode) {
                newPipes.push({
                    id: `T-${nextPipeIdCounter++}`,
                    startNodeId: startNode.id,
                    endNodeId: endNode.id,
                    length: distance,
                    type: 'distribution'
                });
            }
        }
    }

    // Create vertical pipes
    for (let i = 0; i < numVertical - 1; i++) {
        for (let j = 0; j < numHorizontal; j++) {
             const startNode = nodeGrid[i][j];
             const endNode = nodeGrid[i+1][j];
             if (startNode && endNode) {
                newPipes.push({
                    id: `T-${nextPipeIdCounter++}`,
                    startNodeId: startNode.id,
                    endNodeId: endNode.id,
                    length: distance,
                    type: 'distribution'
                });
             }
        }
    }

    updateModel(current => ({
        nodes: [...current.nodes, ...newNodes],
        pipes: [...current.pipes, ...newPipes]
    }));
    
    toast({ title: "Malla Generada", description: `Se crearon ${newNodes.length} nudos y ${newPipes.length} tuberías.` });
};


  const handleMapClick = async (latlng: LatLng, clickedNode: Node | null, clickedPipe: Pipe | null) => {
    const createNewNode = async (latlng: LatLng, currentModel: HydroModel): Promise<Node | null> => {
        toast({ title: "Obteniendo cota del terreno...", description: "Por favor espere." });
        const elevation = await getElevation(latlng.lat, latlng.lng);
        
        if (elevation === null) {
            toast({ title: "Error al obtener la cota", description: "No se pudo obtener la cota del terreno para este punto. Inténtelo de nuevo.", variant: "destructive" });
            return null;
        }

        const nextNodeId = (currentModel.nodes.length > 0 ? Math.max(...currentModel.nodes.map(n => parseInt(n.id.substring(1)) || 0)) : 0) + 1;
        const newId = `N${nextNodeId}`;
        const newNode: Node = {
            id: newId,
            latitud: latlng.lat,
            longitud: latlng.lng,
            cotaTerreno: elevation,
            type: 'node',
        };
        toast({ title: "Nudo Creado", description: `Se ha creado el nudo ${newNode.id} con cota ${elevation.toFixed(2)}m.`});
        return newNode;
    };

    if (drawingMode === 'node' && !clickedNode) {
        const newNode = await createNewNode(latlng, model);
        if (newNode) {
            updateModel(current => ({ ...current, nodes: [...current.nodes, newNode] }));
        }
    } else if (drawingMode === 'pipe' && clickedNode) {
      if (!drawingPipeState.startNode) {
        setDrawingPipeState({ startNode: clickedNode });
        mapRef.current?.highlightNode(clickedNode.id, true);
        mapRef.current?.startGuideLine([clickedNode.latitud, clickedNode.longitud]);
      } else {
        const startNode = drawingPipeState.startNode;
        const endNode = clickedNode;

        if (startNode.id === endNode.id) return;
        
        const newPipe = createNewPipe(startNode, endNode, model.pipes);

        updateModel(current => {
            mapRef.current?.highlightNode(startNode.id, false); 
            setDrawingPipeState({ startNode: endNode });
            mapRef.current?.highlightNode(endNode.id, true);
            mapRef.current?.startGuideLine([endNode.latitud, endNode.longitud]);
            return { ...current, pipes: [...current.pipes, newPipe] };
        });
      }
    } else if (drawingMode === 'dual') {
        let startNode: Node | null = drawingPipeState.startNode;
        let endNode: Node | null = clickedNode;

        if (!startNode) { // First click of a sequence
            if (endNode) { // Clicked on existing node
                startNode = endNode;
            } else { // Clicked on empty space
                startNode = await createNewNode(latlng, model);
                if (startNode) {
                    updateModel(current => ({ ...current, nodes: [...current.nodes, startNode!] }));
                }
            }
            if (startNode) {
                setDrawingPipeState({ startNode });
                mapRef.current?.highlightNode(startNode.id, true);
                mapRef.current?.startGuideLine([startNode.latitud, startNode.longitud]);
            }
        } else { // Subsequent clicks
            if (endNode && startNode.id === endNode.id) return; // Avoid self-connecting pipe

            if (!endNode) { // If not clicking an existing node, create a new one
                endNode = await createNewNode(latlng, model);
            }
            if (!endNode) return; // Stop if node creation failed

            const newPipe = createNewPipe(startNode, endNode, model.pipes);
            
            updateModel(current => {
                mapRef.current?.highlightNode(startNode!.id, false);
                setDrawingPipeState({ startNode: endNode });
                mapRef.current?.highlightNode(endNode!.id, true);
                mapRef.current?.startGuideLine([endNode!.latitud, endNode!.longitud]);
                
                const modelHasEndNode = current.nodes.some(n => n.id === endNode!.id);
                return {
                    nodes: modelHasEndNode ? current.nodes : [...current.nodes, endNode!],
                    pipes: [...current.pipes, newPipe]
                };
            });
        }
    } else if (drawingMode === 'mesh') {
        if (meshState.status === 'settingStart') {
            setMeshState(prev => ({ ...prev, status: 'settingEnd', startPoint: latlng }));
            mapRef.current?.startGuideLine([latlng.lat, latlng.lng]);
             toast({
                title: "Fijar Orientación de Malla",
                description: "Haga clic para definir la dirección y longitud del primer eje horizontal.",
            });
        } else if (meshState.status === 'settingEnd' && meshState.startPoint) {
            mapRef.current?.stopGuideLine();
            setDrawingMode(null);
            await generateMesh(meshState.startPoint, latlng, meshState.params, model);
            setMeshState({ // Reset state
                status: 'configuring',
                params: { numVertical: 7, numHorizontal: 8, distance: 50 },
                startPoint: null,
            });
        }
    } else if (drawingMode === 'measure') {
        if (measureState.status === 'idle') {
            setMeasureState(prev => ({ ...prev, status: 'measuring', startPoint: latlng, distance: null }));
            mapRef.current?.startGuideLine([latlng.lat, latlng.lng], { color: 'red', dashArray: undefined });
        } else if (measureState.status === 'measuring' && measureState.startPoint) {
            const distanceInMeters = measureState.startPoint.distanceTo(latlng);
            mapRef.current?.stopGuideLine();
            mapRef.current?.drawMeasurementResultLine(measureState.startPoint, latlng);
            setMeasureState(prev => ({ ...prev, status: 'idle', startPoint: null, distance: distanceInMeters }));
        }
    } else if (drawingMode === 'delete-component') {
      if (clickedNode) {
        updateModel(current => {
            const nodeIdToDelete = clickedNode.id;
            const newNodes = current.nodes.filter(n => n.id !== nodeIdToDelete);
            const newPipes = current.pipes.filter(p => p.startNodeId !== nodeIdToDelete && p.endNodeId !== nodeIdToDelete);
            const pipesDeletedCount = current.pipes.length - newPipes.length;
            toast({
                title: "Componente Eliminado",
                description: `Se eliminó el nudo ${nodeIdToDelete} y ${pipesDeletedCount} tuberías conectadas.`
            });
            return { nodes: newNodes, pipes: newPipes };
        });
      } else if (clickedPipe) {
          updateModel(current => {
              const newPipes = current.pipes.filter(p => p.id !== clickedPipe.id);
              toast({
                  title: "Componente Eliminado",
                  description: `Se eliminó la tubería ${clickedPipe.id}.`
              });
              return { ...current, pipes: newPipes };
          });
      }
    }
  };

  const handleSave = () => {
    if (!projectData) {
      toast({
        title: "No hay proyecto para guardar",
        description: "Crea o abre un proyecto primero.",
        variant: "destructive",
      });
      return;
    }
  
    const projectStateToSave = {
      project: projectData,
      model: model, 
    };
  
    try {
      localStorage.setItem('hydrobim-project-data', JSON.stringify(projectStateToSave));
      toast({
        title: "Proyecto Guardado Localmente",
        description: `El proyecto "${projectData.nombre}" se guardó en el navegador.`,
      });
    } catch (error: any) {
      console.error("Failed to save project data to localStorage", error);
      const isQuotaError = error instanceof DOMException && (error.name === 'QuotaExceededError' || error.code === 22);
      toast({
        title: "Error al Guardar",
        description: isQuotaError 
          ? "No se pudo guardar el proyecto. El almacenamiento local está lleno."
          : "No se pudo guardar el proyecto localmente.",
        variant: "destructive",
      });
    }
  };
  
  const handleSaveProjectDialog = (data: ProjectData) => {
    setProjectData(data);
    setIsProjectDialogOpen(false);

    const projectStateToSave = {
      project: data,
      model: model,
    };
  
    try {
      localStorage.setItem('hydrobim-project-data', JSON.stringify(projectStateToSave));
      toast({
        title: "Datos de Proyecto Guardados",
        description: `La información del proyecto "${data.nombre}" ha sido actualizada y guardada.`,
      });
    } catch (error: any) {
      console.error("Failed to save project data to localStorage", error);
       const isQuotaError = error instanceof DOMException && (error.name === 'QuotaExceededError' || error.code === 22);
      toast({
        title: "Error al Guardar",
        description: isQuotaError 
          ? "No se pudo guardar el proyecto. El almacenamiento local está lleno."
          : "No se pudo guardar el proyecto localmente.",
        variant: "destructive",
      });
    }

    if (data.latitud && data.longitud) {
       const lat = parseFloat(data.latitud);
       const lng = parseFloat(data.longitud);
       if (!isNaN(lat) && !isNaN(lng)) {
           setTimeout(() => {
             mapRef.current?.setView([lat, lng], 15);
           }, 100);
           setMapCenter([lat, lng]);
           setMapZoom(15);
       }
    }
  };
  
  const handleOpenSaveAsDialog = () => {
    if (!projectData) {
      toast({
        title: "No hay datos que guardar",
        description: "Primero crea un nuevo proyecto o abre uno existente.",
        variant: "destructive",
      });
      return;
    }
    setIsSaveAsDialogOpen(true);
  };

  const executeSaveAs = (fileName: string) => {
    if (!projectData) return;

    const projectStateToSave = {
      project: projectData,
      model: model,
    };
    const jsonString = JSON.stringify(projectStateToSave, null, 2);
    const blob = new Blob([jsonString], { type: "application/json;charset=utf-8" });
    saveAs(blob, `${fileName}.json`);
    toast({
      title: "Proyecto Descargado",
      description: `El proyecto se ha guardado como "${fileName}.json".`,
    });
  };


  const handleOpenStatusDialog = () => {
    setIsStatusDialogOpen(true);
  };

  const handleOpenScopesDialog = () => {
    setIsScopesDialogOpen(true);
  };

  const handleUndo = () => {
    if (historyIndex > 0) {
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        setModel(history[newIndex]);
        toast({
            title: "Acción Deshecha",
            description: "Se ha revertido la última acción.",
        });
    }
  };

  const handleRenumber = () => {
    updateModel(current => {
      const { nodes, pipes } = current;

      const sortedNodes = [...nodes].sort((a, b) => {
        const numA = parseInt(a.id.substring(1)) || 0;
        const numB = parseInt(b.id.substring(1)) || 0;
        return numA - numB;
      });

      const nodeMap = new Map<string, string>();
      const newNodes = sortedNodes.map((node, index) => {
        const newId = `N${index + 1}`;
        nodeMap.set(node.id, newId);
        return { ...node, id: newId };
      });

      const sortedPipes = [...pipes].sort((a, b) => {
        const numA = parseInt(a.id.substring(2)) || 0;
        const numB = parseInt(b.id.substring(2)) || 0;
        return numA - numB;
      });
      
      const newPipes = sortedPipes.map((pipe, index) => {
        const newStartNodeId = nodeMap.get(pipe.startNodeId);
        const newEndNodeId = nodeMap.get(pipe.endNodeId);

        if (!newStartNodeId || !newEndNodeId) {
          console.warn(`Pipe ${pipe.id} references a non-existent node. Skipping.`);
          return null;
        }

        return {
          ...pipe,
          id: `T-${index + 1}`,
          startNodeId: newStartNodeId,
          endNodeId: newEndNodeId,
        };
      }).filter((p): p is Pipe => p !== null);

      toast({
        title: "Componentes Renumerados",
        description: `Se han renumerado ${newNodes.length} nudos y ${newPipes.length} tuberías.`,
      });

      return { nodes: newNodes, pipes: newPipes };
    });
  };

  const handlePurge = () => {
    updateModel(current => {
      let { nodes, pipes } = current;
      let nodesRemovedCount = 0;
      let pipesRemovedCount = 0;
      let duplicatesRemovedCount = 0;

      // 1. Remove duplicate nodes
      const uniqueNodes: Node[] = [];
      const nodeMap = new Map<string, string>(); // oldId -> newId
      const coordsMap = new Map<string, string>(); // 'lat,lng' -> nodeId

      nodes.forEach(node => {
        const coordKey = `${node.latitud.toFixed(6)},${node.longitud.toFixed(6)}`;
        if (coordsMap.has(coordKey)) {
          const existingNodeId = coordsMap.get(coordKey)!;
          nodeMap.set(node.id, existingNodeId);
          duplicatesRemovedCount++;
        } else {
          coordsMap.set(coordKey, node.id);
          nodeMap.set(node.id, node.id);
          uniqueNodes.push(node);
        }
      });
      
      if (duplicatesRemovedCount > 0) {
        pipes = pipes.map(pipe => ({
          ...pipe,
          startNodeId: nodeMap.get(pipe.startNodeId) || pipe.startNodeId,
          endNodeId: nodeMap.get(pipe.endNodeId) || pipe.endNodeId,
        }));
        nodes = uniqueNodes;
      }
      
      // 2. Remove isolated pipes (referencing non-existent nodes)
      const nodeIds = new Set(nodes.map(n => n.id));
      const initialPipesCount = pipes.length;
      pipes = pipes.filter(p => nodeIds.has(p.startNodeId) && nodeIds.has(p.endNodeId));
      pipesRemovedCount += initialPipesCount - pipes.length;

      // 3. Remove orphan nodes
      const connectedNodeIds = new Set();
      pipes.forEach(pipe => {
        connectedNodeIds.add(pipe.startNodeId);
        connectedNodeIds.add(pipe.endNodeId);
      });
      
      const initialNodesCount = nodes.length;
      nodes = nodes.filter(node => connectedNodeIds.has(node.id));
      nodesRemovedCount = initialNodesCount - nodes.length;

      toast({
        title: "Modelo Depurado",
        description: `Se eliminaron ${nodesRemovedCount} nudos huérfanos, ${duplicatesRemovedCount} nudos duplicados y ${pipesRemovedCount} tuberías aisladas.`,
      });

      return { nodes, pipes };
    });
  };

  const handleToolSelect = (tool: DrawingMode | 'project' | null) => {
    cancelDrawing();
    
    if (tool === 'project') {
      handleOpenProjectDialog();
      setDrawingMode(null);
    } else if (tool === 'clean') {
      setIsCleanConfirmDialogOpen(true);
      setDrawingMode(null);
    } else if (tool === 'renumber') {
      setIsRenumberConfirmDialogOpen(true);
      setDrawingMode(null);
    } else if (tool === 'purge') {
        setIsPurgeConfirmDialogOpen(true);
        setDrawingMode(null);
    } else if (tool === 'undo') {
      handleUndo();
      setDrawingMode(null);
    } else if (tool === 'reservoir' || tool === 'valve' || tool === 'pump' || tool === 'tank' || tool === 'wtp' || tool === 'well' || tool === 'intake' || tool === 'vertex' || tool === 'delete-selection' || tool === 'move' || tool === 'viewer') {
        toast({
            title: "Herramienta no implementada",
            description: "Esta funcionalidad estará disponible en futuras versiones.",
        });
        setDrawingMode(null);
    }
    else {
      setDrawingMode(prev => {
        const newMode = prev === tool ? null : tool;
        setHideNodeTooltips(newMode === 'pipe' || newMode === 'dual' || newMode === 'mesh' || newMode === 'delete-component');
        if (newMode === null) {
            cancelDrawing();
        } else {
            if (drawingPipeState.startNode) {
                mapRef.current?.highlightNode(drawingPipeState.startNode.id, false);
                setDrawingPipeState({ startNode: null });
                mapRef.current?.stopGuideLine();
            }
        }
        return newMode;
      });
    }
  };

  const handleImportKmlClick = () => {
    importKmlInputRef.current?.click();
  };

  const handleImportKmlSelected = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    toast({
      title: 'Importando archivo...',
      description: `Procesando ${file.name}.`,
    });

    try {
      updateModel(() => initialModel);
      await new Promise(resolve => setTimeout(resolve, 50)); 

      const { nodes: importedNodes, pipes: importedPipes } = await processKmlFile(file);
      
      updateModel(current => ({
        ...current,
        nodes: importedNodes,
        pipes: importedPipes,
      }));

      toast({
        title: 'Importación Exitosa',
        description: `Se importaron ${importedNodes.length} nudos y ${importedPipes.length} tuberías.`,
      });

      if (!projectData) {
         setProjectData({
            nombre: file.name.replace(/\.(kmz|kml)$/i, ''),
         });
      }

      if (importedNodes.length > 0) {
        const firstNode = importedNodes[0];
        const newCenter: LatLngExpression = [firstNode.latitud, firstNode.longitud];
        setMapCenter(newCenter);
        setMapZoom(16);
        mapRef.current?.setView(newCenter, 16);
      }

    } catch (error) {
      console.error('Error importing KML/KMZ:', error);
      toast({
        title: 'Error de Importación',
        description: (error as Error).message || 'No se pudo procesar el archivo.',
        variant: 'destructive',
      });
    } finally {
      if (event.target) {
        event.target.value = '';
      }
    }
  };

  const handleCsvImport = ({ file, options }: { file: File, options: Record<string, boolean>}) => {
      setIsCsvImportDialogOpen(false);
      toast({
          title: "Importando archivo CSV...",
          description: `Procesando ${file.name}.`,
      });

      Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          transformHeader: header => header.trim().toLowerCase(),
          complete: (results) => {
              if (results.errors.length) {
                  const firstError = results.errors[0];
                  toast({ title: "Error de Análisis CSV", description: `Error en la fila ${firstError.row}: ${firstError.message}`, variant: "destructive" });
                  return;
              }
              
              let importedNodes: Node[] = [];
              if (options.nodes) {
                  const findHeader = (aliases: string[]) => {
                      return results.meta.fields?.find(h => aliases.includes(h.toLowerCase()));
                  }

                  const idHeader = findHeader(['id', 'ids']);
                  const latHeader = findHeader(['lat', 'latitud']);
                  const lngHeader = findHeader(['lng', 'lon', 'longitud']);
                  const elevHeader = findHeader(['elevation', 'elevacion', 'cota', 'cotaterreno']);

                  if (!latHeader || !lngHeader) {
                      toast({ title: "Faltan columnas requeridas", description: "El archivo CSV debe contener cabeceras para latitud (ej: 'lat') y longitud (ej: 'lng').", variant: "destructive"});
                      return;
                  }

                  const existingNodeIds = new Set(model.nodes.map(n => n.id));
                  let nextNodeIdCounter = (model.nodes.length > 0 ? Math.max(...model.nodes.map(n => parseInt(n.id.substring(1)) || 0)) : 0) + 1;
                  
                  importedNodes = (results.data as any[]).map((row: any, index: number) => {
                      const lat = parseFloat(row[latHeader]);
                      const lng = parseFloat(row[lngHeader]);

                      if (isNaN(lat) || isNaN(lng)) {
                          console.warn(`Saltando fila ${index + 2} por coordenadas inválidas.`);
                          return null;
                      }

                      let id = idHeader && row[idHeader] ? String(row[idHeader]).trim() : '';
                      if (!id || existingNodeIds.has(id)) {
                          id = `N${nextNodeIdCounter++}`;
                      }
                      
                      const cota = elevHeader && row[elevHeader] ? parseFloat(row[elevHeader]) : null;

                      return {
                          id,
                          latitud: lat,
                          longitud: lng,
                          cotaTerreno: cota && !isNaN(cota) ? cota : null,
                          type: 'node',
                      };
                  }).filter((node): node is Node => node !== null && !existingNodeIds.has(node.id));
              }

              if (importedNodes.length > 0) {
                  updateModel((current) => ({
                      ...current,
                      nodes: [...current.nodes, ...importedNodes],
                  }));

                  toast({
                      title: "Importación CSV Exitosa",
                      description: `Se importaron ${importedNodes.length} nuevos elementos.`
                  });

                  if (importedNodes.length > 0 && model.nodes.length === 0) {
                      const firstNode = importedNodes[0];
                      const newCenter: LatLngExpression = [firstNode.latitud, firstNode.longitud];
                      setMapCenter(newCenter);
                      setMapZoom(16);
                      mapRef.current?.setView(newCenter, 16);
                  }
              } else {
                  toast({
                      title: "Importación CSV",
                      description: "No se encontraron nuevos elementos para importar en el archivo o el tipo de componente no fue seleccionado.",
                      variant: "destructive",
                  });
              }
          },
          error: (error: Error) => {
             console.error('Error importing CSV:', error);
              toast({
                  title: 'Error de Importación CSV',
                  description: error.message || 'No se pudo procesar el archivo.',
                  variant: 'destructive',
              });
          }
      });
  };

  const getProjectInitials = (name?: string): string => {
    if (!name) return 'PROY';
    return name.split(' ').map(word => word.charAt(0)).join('').toUpperCase() || 'PROY';
  }

  const handleExecuteExport = async (options: { nodes: boolean; pipes: boolean }) => {
    setIsCsvExportDialogOpen(false);
    
    if (!options.nodes && !options.pipes) {
        toast({
            title: "Exportación Cancelada",
            description: "No se seleccionó ningún tipo de componente para exportar.",
            variant: "destructive",
        });
        return;
    }

    const projectInitials = getProjectInitials(projectData?.nombre);

    const zip = new JSZip();
    let filesGenerated = 0;

    if (options.nodes && nodes.length > 0) {
        const nodeData = nodes.map(n => ({
            id: n.id,
            lat: n.latitud,
            lng: n.longitud,
            cotaTerreno: n.cotaTerreno ?? ''
        }));
        const csvContent = Papa.unparse(nodeData, { header: true });
        
        if (options.pipes && pipes.length > 0) {
            zip.file(`Nudos_${projectInitials}.csv`, csvContent);
        } else {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, `Nudos_${projectInitials}.csv`);
        }
        filesGenerated++;
    }

    if (options.pipes && pipes.length > 0) {
        const distributionPipes = pipes.filter(p => p.type === 'distribution');
        const pipeData = distributionPipes.map(p => ({
            id: p.id,
            startNodeId: p.startNodeId,
            endNodeId: p.endNodeId,
            length: p.length.toFixed(2),
        }));
        const csvContent = Papa.unparse(pipeData, { header: true });
        
        if (options.nodes && nodes.length > 0) {
             zip.file(`Tuberias_${projectInitials}.csv`, csvContent);
        } else {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, `Tuberias_${projectInitials}.csv`);
        }
        filesGenerated++;
    }

    if (options.nodes && options.pipes && nodes.length > 0 && pipes.length > 0) {
        try {
            const zipBlob = await zip.generateAsync({ type: "blob" });
            saveAs(zipBlob, `${projectInitials}_export.zip`);
            toast({
                title: "Exportación a ZIP Exitosa",
                description: `Se han exportado nudos y tuberías a ${projectInitials}_export.zip.`
            });
        } catch (error) {
             toast({
                title: "Error al crear ZIP",
                description: "No se pudo generar el archivo comprimido.",
                variant: "destructive",
            });
        }
        return;
    }
    
    if (filesGenerated === 0) {
         toast({
            title: "No hay datos para exportar",
            description: "No existen elementos de los tipos seleccionados en el modelo.",
            variant: "destructive",
        });
        return;
    }
    
    toast({
        title: "Exportación a CSV Exitosa",
        description: `Se ha exportado el archivo seleccionado.`
    });
  };

  const handleExportToKml = () => {
    if (!projectData) {
      toast({
        title: "No hay proyecto para exportar",
        description: "Crea o abre un proyecto primero.",
        variant: "destructive",
      });
      return;
    }

    if (nodes.length === 0 && pipes.length === 0) {
      toast({
        title: "No hay datos para exportar",
        description: "El modelo está vacío.",
        variant: "destructive",
      });
      return;
    }

    try {
        const kmlContent = generateKml(nodes, pipes, projectData.nombre || 'HydroBIM Project');
        const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml;charset=utf-8' });
        const fileName = `${projectData.nombre.replace(/\s+/g, '_') || 'hydrobim-project'}.kml`;
        saveAs(blob, fileName);

        toast({
          title: "Exportación a KML Exitosa",
          description: `Se ha exportado el proyecto a ${fileName}.`
        });
    } catch(error) {
        console.error("Failed to generate KML:", error);
        toast({
            title: "Error al Exportar KML",
            description: "No se pudo generar el archivo KML.",
            variant: "destructive",
        });
    }
  };

  const handleExit = () => {
    setIsExitConfirmDialogOpen(true);
  };
  
  const handleOpenProjectClick = () => {
    openProjectFileInputRef.current?.click();
  };

  const handleOpenProjectFile = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
  
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const text = e.target?.result;
        if (typeof text !== 'string') {
          throw new Error('Error al leer el archivo.');
        }
        const data = JSON.parse(text);
  
        // Simplified and direct check
        if (data && data.project && data.model && Array.isArray(data.model.nodes) && Array.isArray(data.model.pipes)) {
          setProjectData(data.project);
          
          const loadedModel = data.model;
          setModel(loadedModel);
          setHistory([loadedModel]);
          setHistoryIndex(0);
  
          if (data.project.latitud && data.project.longitud) {
            const lat = parseFloat(data.project.latitud);
            const lng = parseFloat(data.project.longitud);
            if (!isNaN(lat) && !isNaN(lng)) {
              const newCenter: LatLngExpression = [lat, lng];
              setMapCenter(newCenter);
              setMapZoom(15);
              mapRef.current?.setView(newCenter, 15);
            }
          }
          toast({
            title: 'Proyecto Abierto Exitosamente',
            description: `Se ha cargado el proyecto "${data.project.nombre}".`,
          });
        } else {
          throw new Error("El archivo no tiene el formato de proyecto HydroBIM válido.");
        }
      } catch (error) {
        console.error('Failed to parse project file:', error);
        toast({
          title: 'Error al Abrir Proyecto',
          description: (error as Error).message || 'El archivo está corrupto o no es válido.',
          variant: 'destructive',
        });
      } finally {
        if (event.target) {
          event.target.value = '';
        }
      }
    };
    reader.readAsText(file);
  };

  const handleSetMeshParams = (params: MeshParams) => {
    setMeshState(prev => ({ ...prev, params }));
  }

  const handleFixAndModelMesh = () => {
    setDrawingMode('mesh');
    setMeshState(prev => ({ ...prev, status: 'settingStart' }));
    toast({
        title: "Fijar Inicio de Malla",
        description: "Haga clic en el mapa para establecer la esquina de la malla.",
    });
  };

  // Measurement Tool Handlers
  const handleMeasureAgain = () => {
    mapRef.current?.clearMeasurementResultLine();
    mapRef.current?.stopGuideLine();
    setMeasureState(prev => ({ ...prev, status: 'idle', distance: null, startPoint: null }));
    toast({
        title: "Medición Reiniciada",
        description: "Haga clic en el mapa para iniciar una nueva medición.",
    });
  };

  const handleMeasureExit = () => {
    mapRef.current?.clearMeasurementResultLine();
    mapRef.current?.stopGuideLine();
    setMeasureState({ status: 'idle', startPoint: null, distance: null, unit: 'm' });
    setDrawingMode(null);
  };

  const handleUnitChange = (unit: MeasureUnit) => {
    setMeasureState(prev => ({ ...prev, unit }));
  };

  return (
    <main className="flex flex-col h-screen">
      <header className="flex h-14 items-center border-b px-4 flex-shrink-0 relative z-20 bg-background">
        <h1 className="text-xl font-bold">HydroBIM</h1>
        <Menubar className="ml-6 border-none shadow-none">
          <MenubarMenu>
            <MenubarTrigger>Archivo</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={handleNewProject}>Nuevo</MenubarItem>
              <MenubarItem onSelect={handleOpenProjectClick}>Abrir</MenubarItem>
              <MenubarSeparator />
              <MenubarItem onSelect={handleSave}>Guardar</MenubarItem>
              <MenubarItem onSelect={handleOpenSaveAsDialog}>Guardar Como</MenubarItem>
              <MenubarSeparator />
              <MenubarSub>
                <MenubarSubTrigger>Importar</MenubarSubTrigger>
                <MenubarSubContent>
                  <MenubarItem onSelect={handleImportKmlClick}>Archivos KMZ/KML</MenubarItem>
                  <MenubarItem onSelect={() => setIsCsvImportDialogOpen(true)}>Archivos CSV</MenubarItem>
                </MenubarSubContent>
              </MenubarSub>
              <MenubarSub>
                <MenubarSubTrigger>Exportar</MenubarSubTrigger>
                <MenubarSubContent>
                  <MenubarItem onSelect={handleExportToKml}>Archivos KML</MenubarItem>
                  <MenubarItem onSelect={() => setIsCsvExportDialogOpen(true)}>Archivos CSV</MenubarItem>
                </MenubarSubContent>
              </MenubarSub>
              <MenubarSeparator />
              <MenubarItem onSelect={handleExit}>Salir</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Datos</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={handleOpenProjectDialog}>Proyecto</MenubarItem>
              <MenubarItem>Parámetros de Diseño</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Mapa GIS</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={() => setMapLayer('streets')}>Calles</MenubarItem>
              <MenubarItem onSelect={() => setMapLayer('topo')}>Topografía</MenubarItem>
              <MenubarItem onSelect={() => setMapLayer('satellite')}>Satelital</MenubarItem>
              <MenubarItem onSelect={() => setMapLayer('neutral')}>Neutral</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Modelado</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={toggleModelingToolbar}>Herramienta de Modelado</MenubarItem>
              <MenubarItem>Topografía</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Sistema o Red</MenubarTrigger>
            <MenubarContent>
              <MenubarSub>
                <MenubarSubTrigger>Datos del Modelado</MenubarSubTrigger>
                <MenubarSubContent>
                  <MenubarItem onSelect={() => setIsNodesDialogOpen(true)}>Nudos</MenubarItem>
                  <MenubarItem>Vértices</MenubarItem>
                  <MenubarItem onSelect={() => setIsPipesDialogOpen(true)}>Tuberías de Distribución</MenubarItem>
                  <MenubarItem>Tuberías de Aducción</MenubarItem>
                  <MenubarItem>Tuberías de Conducción</MenubarItem>
                  <MenubarItem>Reservorios</MenubarItem>
                  <MenubarItem>PTAPs</MenubarItem>
                  <MenubarItem>Bocatomas</MenubarItem>
                </MenubarSubContent>
              </MenubarSub>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Simulación</MenubarTrigger>
            <MenubarContent></MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Configuración</MenubarTrigger>
            <MenubarContent></MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Ayuda</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={handleOpenScopesDialog}>
                Alcances del Aplicativo
              </MenubarItem>
              <MenubarItem onSelect={handleOpenStatusDialog}>
                Estado de Funcionalidad
              </MenubarItem>
            </MenubarContent>
          </MenubarMenu>
        </Menubar>
      </header>
      <div className="flex-grow relative z-10">
        <input
            type="file"
            accept=".kml,.kmz"
            style={{ display: 'none' }}
            ref={importKmlInputRef}
            onChange={handleImportKmlSelected}
        />
        <input
            type="file"
            accept=".json"
            style={{ display: 'none' }}
            ref={openProjectFileInputRef}
            onChange={handleOpenProjectFile}
        />
        <MapComponent 
          ref={mapRef} 
          onMapClick={handleMapClick} 
          drawingMode={drawingMode}
          initialCenter={mapCenter}
          initialZoom={mapZoom}
          nodes={nodes}
          pipes={pipes}
          hideNodeTooltips={hideNodeTooltips}
        />
        {showModelingToolbar && <ModelingToolbar onToolSelect={handleToolSelect} activeTool={drawingMode} canUndo={historyIndex > 0} />}
         {drawingMode === 'mesh' && meshState.status === 'configuring' && (
            <MeshControlCard 
                onParamsChange={handleSetMeshParams}
                onFixAndModel={handleFixAndModelMesh}
                initialParams={meshState.params}
            />
        )}
        {drawingMode === 'measure' && (
            <MeasureControlCard 
                distance={measureState.distance}
                unit={measureState.unit}
                onUnitChange={handleUnitChange}
                onMeasureAgain={handleMeasureAgain}
                onExit={handleMeasureExit}
            />
        )}
        <div className="absolute bottom-4 left-4 z-[999] p-2 bg-background/80 backdrop-blur-sm rounded-md shadow-md text-xs">
            <div>Autor: Ing. Rulli Llancari Anyaipoma</div>
            <div>BIM Proyectos Integrados SAC</div>
        </div>
      </div>
      <ProjectDialog 
        isOpen={isProjectDialogOpen} 
        onOpenChange={setIsProjectDialogOpen}
        onSave={handleSaveProjectDialog}
        initialData={projectData}
      />
       <SaveAsDialog
        isOpen={isSaveAsDialogOpen}
        onOpenChange={setIsSaveAsDialogOpen}
        onSave={executeSaveAs}
        defaultFileName={projectData?.nombre ? projectData.nombre.replace(/\s+/g, '_') : 'hydrobim-project'}
      />
      <StatusDialog isOpen={isStatusDialogOpen} onOpenChange={setIsStatusDialogOpen} />
      <ScopesDialog isOpen={isScopesDialogOpen} onOpenChange={setIsScopesDialogOpen} />
      <NodesDialog isOpen={isNodesDialogOpen} onOpenChange={setIsNodesDialogOpen} nodes={nodes} />
      <PipesDialog isOpen={isPipesDialogOpen} onOpenChange={setIsPipesDialogOpen} pipes={pipes} />
      <CsvImportDialog isOpen={isCsvImportDialogOpen} onOpenChange={setIsCsvImportDialogOpen} onImport={handleCsvImport} />
      <CsvExportDialog
        isOpen={isCsvExportDialogOpen}
        onOpenChange={setIsCsvExportDialogOpen}
        onExport={handleExecuteExport}
        hasNodes={nodes.length > 0}
        hasPipes={pipes.length > 0}
      />
      
      <AlertDialog open={isCleanConfirmDialogOpen} onOpenChange={setIsCleanConfirmDialogOpen}>
        <AlertDialogContent>
            <AlertDialogHeader>
                <AlertDialogTitle>¿Está seguro de limpiar el lienzo?</AlertDialogTitle>
                <AlertDialogDescription>
                    Esta acción es irreversible y borrará todos los nudos y tuberías del proyecto actual.
                </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
                <AlertDialogCancel>Cancelar</AlertDialogCancel>
                <AlertDialogAction onClick={() => { handleClean(); setIsCleanConfirmDialogOpen(false); }}>
                    Sí, limpiar lienzo
                </AlertDialogAction>
            </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <AlertDialog open={isRenumberConfirmDialogOpen} onOpenChange={setIsRenumberConfirmDialogOpen}>
        <AlertDialogContent>
            <AlertDialogHeader>
                <AlertDialogTitle>¿Está seguro de renumerar los componentes?</AlertDialogTitle>
                <AlertDialogDescription>
                    Esta acción reasignará los IDs de todos los nudos y tuberías de forma secuencial, empezando desde 1.
                </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
                <AlertDialogCancel>Cancelar</AlertDialogCancel>
                <AlertDialogAction onClick={() => { handleRenumber(); setIsRenumberConfirmDialogOpen(false); }}>
                    Sí, renumerar
                </AlertDialogAction>
            </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <AlertDialog open={isPurgeConfirmDialogOpen} onOpenChange={setIsPurgeConfirmDialogOpen}>
        <AlertDialogContent>
            <AlertDialogHeader>
                <AlertDialogTitle>¿Está seguro de depurar el modelo?</AlertDialogTitle>
                <AlertDialogDescription>
                    Esta acción eliminará nudos duplicados, nudos huérfanos (no conectados a ninguna tubería) y tuberías que hagan referencia a nudos inexistentes.
                </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
                <AlertDialogCancel>Cancelar</AlertDialogCancel>
                <AlertDialogAction onClick={() => { handlePurge(); setIsPurgeConfirmDialogOpen(false); }}>
                    Sí, depurar
                </AlertDialogAction>
            </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

       <AlertDialog open={isExitConfirmDialogOpen} onOpenChange={setIsExitConfirmDialogOpen}>
        <AlertDialogContent>
            <AlertDialogHeader>
                <AlertDialogTitle>¿Está seguro de que desea salir?</AlertDialogTitle>
                <AlertDialogDescription>
                    Asegúrese de haber guardado su trabajo antes de salir. Cualquier cambio no guardado se perderá.
                </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
                <AlertDialogCancel>No, quedarme</AlertDialogCancel>
                <AlertDialogAction onClick={() => { setIsExitConfirmDialogOpen(false); window.close(); }}>
                    Sí, salir
                </AlertDialogAction>
            </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </main>
  );
}