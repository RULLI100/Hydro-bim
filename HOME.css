
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import {
  Menubar,
  MenubarContent,
  MenubarItem,
  MenubarMenu,
  MenubarSeparator,
  MenubarSub,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarTrigger,
} from "@/components/ui/menubar"
import dynamic from 'next/dynamic';
import type { MapRef } from '@/components/Map';
import ModelingToolbar from '@/components/ModelingToolbar';
import ProjectDialog from '@/components/ProjectDialog';
import type { ProjectData } from '@/components/ProjectDialog';
import { useToast } from '@/hooks/use-toast';
import StatusDialog from '@/components/StatusDialog';
import NodesDialog from '@/components/NodesDialog';
import PipesDialog from '@/components/PipesDialog';
import type { Node, Pipe, Vertex, Reservoir, Connectable, PTAP, Bocatoma, Captacion, PozoProfundo, TanqueElevado, HydroModel } from '@/types/hydro';
import type { LatLng, LatLngBounds, LatLngExpression } from 'leaflet';
import { getElevation } from '@/app/actions';
import { saveAs } from 'file-saver';
import SaveAsDialog from './SaveAsDialog';
import ScopesDialog from './ScopesDialog';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from './ui/alert-dialog';
import { processKmlFile } from '@/lib/kml-importer';
import CsvImportDialog from './CsvImportDialog';
import Papa from 'papaparse';
import CsvExportDialog from './CsvExportDialog';
import JSZip from 'jszip';
import { generateKml } from '@/lib/kml-generator';
import MeshControlCard from './MeshControlCard';
import type { MeshParams } from './MeshControlCard';
import MeasureControlCard from './MeasureControlCard';
import type { MeasureUnit } from './MeasureControlCard';
import { isPointInPolygon } from '@/lib/geometry';
import VerticesDialog from './VerticesDialog';
import ReservoirsDialog from './ReservoirsDialog';
import PTAPsDialog from './PTAPsDialog';
import BocatomasDialog from './BocatomasDialog';
import CaptacionesDialog from './CaptacionesDialog';
import PozosProfundosDialog from './PozosProfundosDialog';
import TanquesElevadosDialog from './TanquesElevadosDialog';

const MapComponent = dynamic(() => import('@/components/Map'), { ssr: false });

type DrawingMode = 'node' | 'pipe' | 'reservoir' | 'valve-purge' | 'valve-air' | 'valve-control' | 'pump' | 'tank' | 'wtp' | 'well' | 'intake' | 'captation' | 'vertex' | 'dual' | 'mesh' | 'delete-component' | 'measure' | 'delete-selection' | 'clean' | 'purge' | 'renumber' | 'move' | 'viewer' | 'undo' | 'chamber-pumping' | 'chamber-junction' | 'chamber-pressure-break';

type MeshState = {
    status: 'configuring' | 'settingStart' | 'settingEnd';
    params: MeshParams;
    startPoint: LatLng | null;
}

type MeasureState = {
    status: 'idle' | 'measuring';
    startPoint: LatLng | null;
    distance: number | null;
    unit: MeasureUnit;
}


const initialModel: HydroModel = {
  nodes: [
    { id: 'N1', latitud: -12.045, longitud: -77.040, cotaTerreno: 150, type: 'node' },
    { id: 'N2', latitud: -12.050, longitud: -77.045, cotaTerreno: 155, type: 'node' },
    { id: 'N3', latitud: -12.045, longitud: -77.050, cotaTerreno: 160, type: 'node' },
  ],
  pipes: [
    { id: 'T-1', startNodeId: 'N1', endNodeId: 'N2', length: 780, type: 'distribution', vertexIds: [] },
    { id: 'T-2', startNodeId: 'N2', endNodeId: 'N3', length: 555, type: 'distribution', vertexIds: [] },
  ],
  vertices: [],
  reservoirs: [],
  ptaps: [],
  bocatomas: [],
  captaciones: [],
  pozosProfundos: [],
  tanquesElevados: []
};


export default function Home() {
  const mapRef = useRef<MapRef>(null);
  const importKmlInputRef = useRef<HTMLInputElement>(null);
  const openProjectFileInputRef = useRef<HTMLInputElement>(null);
  const [showModelingToolbar, setShowModelingToolbar] = useState(false);
  const [isProjectDialogOpen, setIsProjectDialogOpen] = useState(false);
  const [isStatusDialogOpen, setIsStatusDialogOpen] = useState(false);
  const [isScopesDialogOpen, setIsScopesDialogOpen] = useState(false);
  const [isNodesDialogOpen, setIsNodesDialogOpen] = useState(false);
  const [isPipesDialogOpen, setIsPipesDialogOpen] = useState(false);
  const [isVerticesDialogOpen, setIsVerticesDialogOpen] = useState(false);
  const [isReservoirsDialogOpen, setIsReservoirsDialogOpen] = useState(false);
  const [isPtapsDialogOpen, setIsPtapsDialogOpen] = useState(false);
  const [isBocatomasDialogOpen, setIsBocatomasDialogOpen] = useState(false);
  const [isCaptacionesDialogOpen, setIsCaptacionesDialogOpen] = useState(false);
  const [isPozosProfundosDialogOpen, setIsPozosProfundosDialogOpen] = useState(false);
  const [isTanquesElevadosDialogOpen, setIsTanquesElevadosDialogOpen] = useState(false);
  const [isSaveAsDialogOpen, setIsSaveAsDialogOpen] = useState(false);
  const [isCleanConfirmDialogOpen, setIsCleanConfirmDialogOpen] = useState(false);
  const [isRenumberConfirmDialogOpen, setIsRenumberConfirmDialogOpen] = useState(false);
  const [isPurgeConfirmDialogOpen, setIsPurgeConfirmDialogOpen] = useState(false);
  const [isCsvImportDialogOpen, setIsCsvImportDialogOpen] = useState(false);
  const [isCsvExportDialogOpen, setIsCsvExportDialogOpen] = useState(false);
  const [isExitConfirmDialogOpen, setIsExitConfirmDialogOpen] = useState(false);

  const [projectData, setProjectData] = useState<ProjectData | null>(null);
  const [drawingMode, setDrawingMode] = useState<DrawingMode | null>(null);
  const [drawingPipeState, setDrawingPipeState] = useState<{ startComponent: Connectable | null }>({ startComponent: null });
  const [hideNodeTooltips, setHideNodeTooltips] = useState(false);

  const [meshState, setMeshState] = useState<MeshState>({
    status: 'configuring',
    params: { numVertical: 7, numHorizontal: 8, distance: 50 },
    startPoint: null,
  });

  const [measureState, setMeasureState] = useState<MeasureState>({
    status: 'idle',
    startPoint: null,
    distance: null,
    unit: 'm'
  });

  const [selectionPolygon, setSelectionPolygon] = useState<LatLng[]>([]);
  const [viewerBoxPoints, setViewerBoxPoints] = useState<LatLng[]>([]);
  
  const { toast } = useToast();

  const [mapCenter, setMapCenter] = useState<LatLngExpression>([-12.046374, -77.042793]);
  const [mapZoom, setMapZoom] = useState<number>(13);

  const [model, setModel] = useState<HydroModel>(initialModel);
  const [history, setHistory] = useState<HydroModel[]>([initialModel]);
  const [historyIndex, setHistoryIndex] = useState(0);

  const { nodes, pipes, vertices, reservoirs, ptaps, bocatomas, captaciones, pozosProfundos, tanquesElevados } = model;
  
  const updateModel = useCallback((modelUpdater: (current: HydroModel) => HydroModel) => {
    setModel(prevModel => {
        const newModel = modelUpdater(prevModel);
        const newHistoryState = [...history.slice(0, historyIndex + 1), newModel];
        setHistory(newHistoryState);
        setHistoryIndex(newHistoryState.length - 1);
        return newModel;
    });
  }, [history, historyIndex]);

  useEffect(() => {
    try {
      const savedData = localStorage.getItem('hydrobim-project-data');
      if (savedData) {
        const parsedData = JSON.parse(savedData);
        if (parsedData.project && parsedData.model) {
          setProjectData(parsedData.project);
          
          const loadedModel: HydroModel = {
            ...initialModel,
            ...parsedData.model,
            pipes: (parsedData.model.pipes || []).map((p: Pipe) => ({ ...p, vertexIds: p.vertexIds || [] })),
            vertices: parsedData.model.vertices || [],
            reservoirs: (parsedData.model.reservoirs || []).map((r: any) => ({ ...r, horasConsumo: r.horasConsumo || 0, horasLlenado: r.horasLlenado || 0, volumenReserva: r.volumenReserva || 0, volumenContraIncendio: r.volumenContraIncendio || 0 })),
            ptaps: parsedData.model.ptaps || [],
            bocatomas: parsedData.model.bocatomas || [],
            captaciones: parsedData.model.captaciones || [],
            pozosProfundos: parsedData.model.pozosProfundos || [],
            tanquesElevados: parsedData.model.tanquesElevados || [],
          };
          
          setModel(loadedModel);
          setHistory([loadedModel]);
          setHistoryIndex(0);

          if (parsedData.project.latitud && parsedData.project.longitud) {
            const lat = parseFloat(parsedData.project.latitud);
            const lng = parseFloat(parsedData.project.longitud);
            if (!isNaN(lat) && !isNaN(lng)) {
              setMapCenter([lat, lng]);
              setMapZoom(15);
            }
          }
          
          if(loadedModel && (loadedModel.nodes.length > 0 || loadedModel.pipes.length > 0)) {
            setTimeout(() => {
                toast({
                  title: "Proyecto Cargado",
                  description: `Se ha cargado el proyecto "${parsedData.project.nombre}" desde la sesión anterior.`,
                });
            }, 100);
          }
        }
      } else {
        setModel(initialModel);
        setHistory([initialModel]);
        setHistoryIndex(0);
      }
    } catch (error) {
      console.error("Failed to load or parse project data from localStorage", error);
      setModel(initialModel);
      setHistory([initialModel]);
      setHistoryIndex(0);
      setTimeout(() => {
          toast({
            title: "Error al cargar",
            description: "No se pudo cargar el proyecto guardado. Puede estar corrupto.",
            variant: "destructive",
          });
      }, 100);
    }
  }, [toast]);

  const handleDeleteSelection = useCallback(() => {
    if (selectionPolygon.length < 3) {
      toast({
        title: "Selección Inválida",
        description: "Debe seleccionar al menos 3 puntos para formar un polígono.",
        variant: "destructive"
      });
      setSelectionPolygon([]);
      return;
    }

    updateModel(current => {
      const nodesToDelete = new Set<string>();
      
      current.nodes.forEach(node => {
        if (isPointInPolygon({ lat: node.latitud, lng: node.longitud }, selectionPolygon)) {
          nodesToDelete.add(node.id);
        }
      });
  
      if (nodesToDelete.size === 0) {
        toast({ title: "Sin Resultados", description: "Ningún nudo encontrado dentro de la selección." });
        setSelectionPolygon([]);
        setDrawingMode(null);
        return current;
      }

      const newNodes = current.nodes.filter(n => !nodesToDelete.has(n.id));
      
      const newPipes = current.pipes.filter(p => 
        !nodesToDelete.has(p.startNodeId) && !nodesToDelete.has(p.endNodeId)
      );

      const nodesDeletedCount = current.nodes.length - newNodes.length;
      const pipesDeletedCount = current.pipes.length - newPipes.length;
      
      toast({
        title: "Selección Eliminada",
        description: `Se eliminaron ${nodesDeletedCount} nudos y ${pipesDeletedCount} tuberías.`
      });

      return { ...current, nodes: newNodes, pipes: newPipes };
    });

    setSelectionPolygon([]);
    setDrawingMode(null);
  }, [selectionPolygon, updateModel, toast]);

  const cancelDrawing = useCallback(() => {
    if (drawingPipeState.startComponent) {
      mapRef.current?.highlightNode(drawingPipeState.startComponent.id, false);
      setDrawingPipeState({ startComponent: null });
    }
    setDrawingPipeState({ startComponent: null });
    setDrawingMode(null);
    mapRef.current?.stopGuideLine();

    if(drawingMode === 'mesh') {
        setMeshState({
            status: 'configuring',
            params: { numVertical: 7, numHorizontal: 8, distance: 50 },
            startPoint: null,
        });
    }
    if (drawingMode === 'measure') {
        handleMeasureExit();
    }
    if (drawingMode === 'delete-selection') {
      setSelectionPolygon([]);
    }
    if (drawingMode === 'viewer') {
        setViewerBoxPoints([]);
    }

  }, [drawingMode, drawingPipeState.startComponent]);

  const resetPipeDrawing = () => {
    if (drawingPipeState.startComponent) {
        mapRef.current?.highlightNode(drawingPipeState.startComponent.id, false);
        setDrawingPipeState({ startComponent: null });
        mapRef.current?.stopGuideLine();
        toast({
            title: "Modelado de Tubería Reiniciado",
            description: "Seleccione un nuevo componente de inicio.",
        });
    }
  }

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        if(drawingMode) {
            cancelDrawing();
            toast({
                title: "Modelado Cancelado",
                description: "Se ha salido del modo de modelado.",
            });
        }
      }
      if (event.key === 'Enter') {
          if ((drawingMode === 'pipe' || drawingMode === 'dual') && drawingPipeState.startComponent) {
              resetPipeDrawing();
          } else if (drawingMode === 'delete-selection' && selectionPolygon.length > 0) {
            handleDeleteSelection();
          }
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [drawingMode, drawingPipeState.startComponent, cancelDrawing, selectionPolygon, handleDeleteSelection]);

  const setMapLayer = (layer: 'streets' | 'topo' | 'satellite' | 'neutral') => {
    mapRef.current?.setLayer(layer);
  };

  const toggleModelingToolbar = () => {
    setShowModelingToolbar(prevState => !prevState);
  };
  
  const handleOpenProjectDialog = () => {
    setIsProjectDialogOpen(true);
  };

  const handleClean = () => {
    updateModel(() => initialModel);
    localStorage.removeItem('hydrobim-project-data');
    toast({
        title: "Lienzo Limpiado",
        description: "Se han borrado todos los nudos y tuberías del modelo.",
    });
  };

  const handleNewProject = useCallback(() => {
    setProjectData(null);
    updateModel(() => initialModel);
    
    const defaultCenter: LatLngExpression = [-12.046374, -77.042793];
    setMapCenter(defaultCenter);
    setMapZoom(13);
    mapRef.current?.setView(defaultCenter, 13);
    
    setIsProjectDialogOpen(true);
    
    setTimeout(() => {
      toast({
        title: "Nuevo Proyecto Iniciado",
        description: "Introduce los datos para tu nuevo proyecto. El lienzo ha sido limpiado.",
      });
    }, 100);
  }, [updateModel, toast]);
  
  const createNewPipe = (startComponent: Connectable, endComponent: Connectable, currentPipes: Pipe[]): Pipe => {
      const R = 6371e3; // metres
      const φ1 = startComponent.latitud * Math.PI/180;
      const φ2 = endComponent.latitud * Math.PI/180;
      const Δφ = (endComponent.latitud-startComponent.latitud) * Math.PI/180;
      const Δλ = (endComponent.longitud-startComponent.longitud) * Math.PI/180;
      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      const length = R * c;

      const nextPipeNumber = (currentPipes.length > 0 ? Math.max(...currentPipes.map(p => parseInt(p.id.substring(2)) || 0)) : 0) + 1;
      const newPipeId = `T-${nextPipeNumber}`;
      
      const newPipe: Pipe = {
        id: newPipeId,
        startNodeId: startComponent.id,
        endNodeId: endComponent.id,
        length: length,
        type: 'distribution',
        vertexIds: [],
      };

      setTimeout(() => {
        toast({
          title: "Tubería Creada",
          description: `Se ha creado la tubería ${newPipe.id} entre ${startComponent.id} y ${endComponent.id} con una longitud de ${length.toFixed(2)}m.`
        });
      }, 0);

      return newPipe;
  };
  
 const generateMesh = async (startPoint: LatLng, endPoint: LatLng, params: MeshParams, currentModel: HydroModel) => {
    toast({ title: "Generando Malla...", description: "Por favor espere. Este proceso puede tardar." });
    
    const { numHorizontal, numVertical, distance } = params;

    if (numHorizontal < 1 || numVertical < 1) {
        toast({title: "Parámetros de Malla Inválidos", description: "El número de ejes debe ser al menos 1.", variant: "destructive"});
        return;
    }

    const newNodes: Node[] = [];
    const newPipes: Pipe[] = [];
    
    const nodeGrid: (Node | null)[][] = Array.from({ length: numVertical }, () => Array(numHorizontal).fill(null));
    
    const latDegPerMeter = 1 / 111132.954;
    const lonDegPerMeterAtLat = (lat: number) => 1 / (111320 * Math.cos(lat * Math.PI / 180));
    
    const baseVectorLat = endPoint.lat - startPoint.lat;
    const baseVectorLng = endPoint.lng - startPoint.lng;
    const baseVectorMag = Math.sqrt(baseVectorLat**2 + baseVectorLng**2);

    const unitVectorLat = baseVectorMag > 0 ? baseVectorLat / baseVectorMag : 0;
    const unitVectorLng = baseVectorMag > 0 ? baseVectorLng / baseVectorMag : 0;
    
    // Perpendicular vector (anti-clockwise)
    const perpUnitVectorLat = -unitVectorLng;
    const perpUnitVectorLng = unitVectorLat;
    
    const dx_h = unitVectorLng * distance * lonDegPerMeterAtLat(startPoint.lat);
    const dy_h = unitVectorLat * distance * latDegPerMeter;
    const dx_v = perpUnitVectorLng * distance * lonDegPerMeterAtLat(startPoint.lat);
    const dy_v = perpUnitVectorLat * distance * latDegPerMeter;


    let nextNodeIdCounter = (currentModel.nodes.length > 0 ? Math.max(...currentModel.nodes.map(n => parseInt(n.id.substring(1)) || 0)) : 0) + 1;
    
    for (let i = 0; i < numVertical; i++) {
        for (let j = 0; j < numHorizontal; j++) {
            
            const newLng = startPoint.lng + j * dx_h + i * dx_v;
            const newLat = startPoint.lat + j * dy_h + i * dy_v;
            
            const elevation = await getElevation(newLat, newLng);
            
            const newNode: Node = {
                id: `N${nextNodeIdCounter++}`,
                latitud: newLat,
                longitud: newLng,
                cotaTerreno: elevation,
                type: 'node'
            };
            newNodes.push(newNode);
            nodeGrid[i][j] = newNode;
        }
    }
    
    let nextPipeIdCounter = (currentModel.pipes.length > 0 ? Math.max(...currentModel.pipes.map(p => parseInt(p.id.substring(2)) || 0)) : 0) + 1;

    for (let i = 0; i < numVertical; i++) {
        for (let j = 0; j < numHorizontal - 1; j++) {
            const startNode = nodeGrid[i][j];
            const endNode = nodeGrid[i][j+1];
            if(startNode && endNode) {
                newPipes.push({
                    id: `T-${nextPipeIdCounter++}`,
                    startNodeId: startNode.id,
                    endNodeId: endNode.id,
                    length: distance,
                    type: 'distribution',
                    vertexIds: [],
                });
            }
        }
    }

    for (let i = 0; i < numVertical - 1; i++) {
        for (let j = 0; j < numHorizontal; j++) {
             const startNode = nodeGrid[i][j];
             const endNode = nodeGrid[i+1][j];
             if (startNode && endNode) {
                newPipes.push({
                    id: `T-${nextPipeIdCounter++}`,
                    startNodeId: startNode.id,
                    endNodeId: endNode.id,
                    length: distance,
                    type: 'distribution',
                    vertexIds: [],
                });
             }
        }
    }

    updateModel(current => ({
        ...current,
        nodes: [...current.nodes, ...newNodes],
        pipes: [...current.pipes, ...newPipes]
    }));
    
    toast({ title: "Malla Generada", description: `Se crearon ${newNodes.length} nudos y ${newPipes.length} tuberías.` });
};

const handleInsertVertex = async (pipeId: string, latlng: LatLng) => {
    toast({ title: "Insertando vértice...", description: "Obteniendo cota del terreno." });
    const elevation = await getElevation(latlng.lat, latlng.lng);

    updateModel(current => {
        const nextVertexIdCounter = (current.vertices.length > 0 ? Math.max(...current.vertices.map(v => parseInt(v.id.substring(2)) || 0)) : 0) + 1;
        const newVertexId = `Vd${nextVertexIdCounter}`;
        
        const newVertex: Vertex = {
            id: newVertexId,
            latitud: latlng.lat,
            longitud: latlng.lng,
            cotaTerreno: elevation,
        };

        const newPipes = current.pipes.map(pipe => {
            if (pipe.id === pipeId) {
                const newVertexIds = [...(pipe.vertexIds || []), newVertex.id];

                const allConnectables: (Connectable)[] = [...current.nodes, ...current.reservoirs];
                const startNode = allConnectables.find(c => c.id === pipe.startNodeId);
                const endNode = allConnectables.find(c => c.id === pipe.endNodeId);
                if (!startNode || !endNode) return pipe;
                
                const allPipeVerticesWithNew = [...(pipe.vertexIds || [])
                    .map(vId => current.vertices.find(v => v.id === vId))
                    .filter((v): v is Vertex => !!v), newVertex];


                const allPoints = [
                    { lat: startNode.latitud, lng: startNode.longitud },
                    ...allPipeVerticesWithNew.map(v => ({ lat: v.latitud, lng: v.longitud })),
                    { lat: endNode.latitud, lng: endNode.longitud }
                ];
                
                let newLength = 0;
                for (let i = 0; i < allPoints.length - 1; i++) {
                    newLength += mapRef.current?.calculateDistance(
                        [allPoints[i].lat, allPoints[i].lng],
                        [allPoints[i + 1].lat, allPoints[i + 1].lng]
                    ) || 0;
                }

                toast({
                    title: "Vértice Agregado",
                    description: `Se agregó el vértice ${newVertex.id} a la tubería ${pipe.id}. Nueva longitud: ${newLength.toFixed(2)}m.`
                });

                return { ...pipe, vertexIds: newVertexIds, length: newLength };
            }
            return pipe;
        });

        return {
            ...current,
            vertices: [...current.vertices, newVertex],
            pipes: newPipes
        };
    });
};

const handlePipeSplit = async (pipe: Pipe, latlng: LatLng) => {
    const allConnectablesBeforeInsert: Connectable[] = [...model.nodes, ...model.reservoirs, ...model.ptaps, ...model.bocatomas, ...model.captaciones, ...model.pozosProfundos, ...model.tanquesElevados];
    const startComponent = allConnectablesBeforeInsert.find(c => c.id === pipe.startNodeId);
    const endComponent = allConnectablesBeforeInsert.find(c => c.id === pipe.endNodeId);
    
    if (!startComponent || !endComponent) return;
    
    const newLength1 = mapRef.current?.calculateDistance(
        [startComponent.latitud, startComponent.longitud],
        [latlng.lat, latlng.lng]
    ) || 0;
    
    const newLength2 = mapRef.current?.calculateDistance(
        [latlng.lat, latlng.lng],
        [endComponent.latitud, endComponent.longitud]
    ) || 0;

    const MIN_PIPE_LENGTH = 2.5;
    if (newLength1 < MIN_PIPE_LENGTH || newLength2 < MIN_PIPE_LENGTH) {
        toast({
            title: "División de Tubería Cancelada",
            description: `La tubería no se puede dividir aquí porque crearía un tramo demasiado corto (menor a ${MIN_PIPE_LENGTH}m).`,
            variant: "destructive",
        });
        return;
    }

    const insertedNode = await createNewNode(latlng, model);
    if (!insertedNode) return;

    updateModel(current => {
        const nextPipeNumber = (current.pipes.length > 0 ? Math.max(...current.pipes.map(p => parseInt(p.id.substring(2)) || 0)) : 0) + 1;
        const newPipeId = `T-${nextPipeNumber}`;

        // The original pipe is now the first segment
        const modifiedPipe: Pipe = {
            ...pipe,
            endNodeId: insertedNode.id,
            length: newLength1,
            vertexIds: [], // Vertices are cleared on split
        };

        // The new pipe is the second segment
        const newPipe: Pipe = {
            id: newPipeId,
            startNodeId: insertedNode.id,
            endNodeId: endComponent.id,
            length: newLength2,
            type: pipe.type,
            vertexIds: [], // Vertices are cleared on split
        };
       
        toast({
            title: "Tubería Dividida",
            description: `La tubería ${pipe.id} ha sido dividida por el nudo ${insertedNode.id}. Se creó la tubería ${newPipe.id}.`,
        });

        const otherPipes = current.pipes.filter(p => p.id !== pipe.id);

        return {
            ...current,
            nodes: [...current.nodes, insertedNode],
            pipes: [...otherPipes, modifiedPipe, newPipe],
        };
    });
};


  const createNewNode = async (latlng: LatLng, currentModel: HydroModel): Promise<Node | null> => {
      toast({ title: "Obteniendo cota del terreno...", description: "Por favor espere." });
      const elevation = await getElevation(latlng.lat, latlng.lng);
      
      if (elevation === null) {
          toast({ title: "Error al obtener la cota", description: "No se pudo obtener la cota del terreno para este punto. Inténtelo de nuevo.", variant: "destructive" });
          return null;
      }

      const nextNodeId = (currentModel.nodes.length > 0 ? Math.max(...currentModel.nodes.map(n => parseInt(n.id.substring(1)) || 0)) : 0) + 1;
      const newId = `N${nextNodeId}`;
      const newNode: Node = {
          id: newId,
          latitud: latlng.lat,
          longitud: latlng.lng,
          cotaTerreno: elevation,
          type: 'node',
      };
      toast({ title: "Nudo Creado", description: `Se ha creado el nudo ${newNode.id} con cota ${elevation.toFixed(2)}m.`});
      return newNode;
  };

  const handleMapClick = async (latlng: LatLng, clickedComponent: Connectable | null, clickedPipe: Pipe | null, clickedVertex: Vertex | null) => {
    
    const createNewReservoir = async (latlng: LatLng, currentModel: HydroModel): Promise<Reservoir | null> => {
        toast({ title: "Creando reservorio...", description: "Obteniendo cota del terreno." });
        const elevation = await getElevation(latlng.lat, latlng.lng);

        const nextReservoirId = (currentModel.reservoirs.length > 0 ? Math.max(...currentModel.reservoirs.map(r => parseInt(r.id.substring(1)) || 0)) : 0) + 1;
        const newId = `R${nextReservoirId}`;

        const newReservoir: Reservoir = {
            id: newId,
            latitud: latlng.lat,
            longitud: latlng.lng,
            cota: elevation,
            volumen: 0,
            caudalIngreso: 0,
            caudalSalida: 0,
            presionIngreso: 0,
            presionSalida: 0,
            horasConsumo: 0,
            horasLlenado: 0,
            volumenReserva: 0,
            volumenContraIncendio: 0,
        };
        toast({ title: "Reservorio Creado", description: `Se ha creado el reservorio ${newReservoir.id} con cota ${elevation?.toFixed(2) ?? 'N/A'}m.` });
        return newReservoir;
    };

    const createNewPTAP = async (latlng: LatLng, currentModel: HydroModel): Promise<PTAP | null> => {
        toast({ title: "Creando PTAP...", description: "Obteniendo cota del terreno." });
        const elevation = await getElevation(latlng.lat, latlng.lng);

        const nextPTAPId = (currentModel.ptaps.length > 0 ? Math.max(...currentModel.ptaps.map(r => parseInt(r.id.substring(1)) || 0)) : 0) + 1;
        const newId = `P${nextPTAPId}`;

        const newPTAP: PTAP = {
            id: newId,
            latitud: latlng.lat,
            longitud: latlng.lng,
            cota: elevation,
            evaporationOrLossPercentage: 0,
            inflowRate: 0,
            outflowRate: 0,
            supplyHours: 0,
            feedHours: 0,
        };
        toast({ title: "PTAP Creada", description: `Se ha creado la PTAP ${newPTAP.id} con cota ${elevation?.toFixed(2) ?? 'N/A'}m.` });
        return newPTAP;
    };

    const createNewBocatoma = async (latlng: LatLng, currentModel: HydroModel): Promise<Bocatoma | null> => {
        toast({ title: "Creando Bocatoma...", description: "Obteniendo cota del terreno." });
        const elevation = await getElevation(latlng.lat, latlng.lng);

        const nextBocatomaId = (currentModel.bocatomas.length > 0 ? Math.max(...currentModel.bocatomas.map(b => parseInt(b.id.substring(1)) || 0)) : 0) + 1;
        const newId = `B${nextBocatomaId}`;

        const newBocatoma: Bocatoma = {
            id: newId,
            latitud: latlng.lat,
            longitud: latlng.lng,
            cota: elevation,
            caudalSalida: 0,
            presionSalida: 0,
        };
        toast({ title: "Bocatoma Creada", description: `Se ha creado la bocatoma ${newBocatoma.id} con cota ${elevation?.toFixed(2) ?? 'N/A'}m.` });
        return newBocatoma;
    };

    const createNewCaptacion = async (latlng: LatLng, currentModel: HydroModel): Promise<Captacion | null> => {
        toast({ title: "Creando Captación...", description: "Obteniendo cota del terreno." });
        const elevation = await getElevation(latlng.lat, latlng.lng);

        const nextCaptacionId = (currentModel.captaciones.length > 0 ? Math.max(...currentModel.captaciones.map(c => parseInt(c.id.substring(1)) || 0)) : 0) + 1;
        const newId = `C${nextCaptacionId}`;

        const newCaptacion: Captacion = {
            id: newId,
            latitud: latlng.lat,
            longitud: latlng.lng,
            cota: elevation,
            caudalSalida: 0,
            presionSalida: 0,
        };
        toast({ title: "Captación Creada", description: `Se ha creado la captación ${newCaptacion.id} con cota ${elevation?.toFixed(2) ?? 'N/A'}m.` });
        return newCaptacion;
    };

    const createNewPozoProfundo = async (latlng: LatLng, currentModel: HydroModel): Promise<PozoProfundo | null> => {
        toast({ title: "Creando Pozo Profundo...", description: "Obteniendo cota del terreno." });
        const elevation = await getElevation(latlng.lat, latlng.lng);

        const nextPozoId = (currentModel.pozosProfundos.length > 0 ? Math.max(...currentModel.pozosProfundos.map(p => parseInt(p.id.substring(2)) || 0)) : 0) + 1;
        const newId = `Pp${nextPozoId}`;

        const newPozo: PozoProfundo = {
            id: newId,
            latitud: latlng.lat,
            longitud: latlng.lng,
            cotaTerreno: elevation,
            cotaSuccion: 0,
            caudalSalida: 0,
            horasSuccion: 0,
            volumenRequerido: 0,
        };
        toast({ title: "Pozo Profundo Creado", description: `Se ha creado el pozo ${newPozo.id} con cota ${elevation?.toFixed(2) ?? 'N/A'}m.` });
        return newPozo;
    };

    const createNewTanqueElevado = async (latlng: LatLng, currentModel: HydroModel): Promise<TanqueElevado | null> => {
        toast({ title: "Creando Tanque Elevado...", description: "Obteniendo cota del terreno." });
        const elevation = await getElevation(latlng.lat, latlng.lng);

        const nextIdCounter = (currentModel.tanquesElevados.length > 0 ? Math.max(...currentModel.tanquesElevados.map(p => parseInt(p.id.substring(2)) || 0)) : 0) + 1;
        const newId = `Te${nextIdCounter}`;

        const newTanque: TanqueElevado = {
            id: newId,
            latitud: latlng.lat,
            longitud: latlng.lng,
            cotaTerreno: elevation,
            cotaSuministro: 0,
            caudalIngreso: 0,
            caudalSalida: 0,
            caudalSuministro: 0,
            horasSuministro: 0,
            horasLlenado: 0,
            volumenRequerido: 0,
            volumenReserva: 0,
            volumenContraIncendio: 0,
        };
        toast({ title: "Tanque Elevado Creado", description: `Se ha creado el tanque ${newTanque.id} con cota ${elevation?.toFixed(2) ?? 'N/A'}m.` });
        return newTanque;
    };

    if (drawingMode === 'node') {
        if (clickedPipe) {
            await handlePipeSplit(clickedPipe, latlng);
        } else if (!clickedComponent) {
            const newNode = await createNewNode(latlng, model);
            if (newNode) {
                updateModel(current => ({ ...current, nodes: [...current.nodes, newNode] }));
            }
        }
    } else if (drawingMode === 'reservoir') {
        const newReservoir = await createNewReservoir(latlng, model);
        if (newReservoir) {
            updateModel(current => ({ ...current, reservoirs: [...current.reservoirs, newReservoir] }));
        }
    } else if (drawingMode === 'wtp') {
        const newPTAP = await createNewPTAP(latlng, model);
        if (newPTAP) {
            updateModel(current => ({ ...current, ptaps: [...current.ptaps, newPTAP] }));
        }
    } else if (drawingMode === 'intake') {
        const newBocatoma = await createNewBocatoma(latlng, model);
        if (newBocatoma) {
            updateModel(current => ({ ...current, bocatomas: [...current.bocatomas, newBocatoma] }));
        }
    } else if (drawingMode === 'captation') {
        const newCaptacion = await createNewCaptacion(latlng, model);
        if (newCaptacion) {
            updateModel(current => ({ ...current, captaciones: [...current.captaciones, newCaptacion] }));
        }
    } else if (drawingMode === 'well') {
        const newPozo = await createNewPozoProfundo(latlng, model);
        if (newPozo) {
            updateModel(current => ({ ...current, pozosProfundos: [...current.pozosProfundos, newPozo] }));
        }
    } else if (drawingMode === 'tank') {
        const newTanque = await createNewTanqueElevado(latlng, model);
        if (newTanque) {
            updateModel(current => ({ ...current, tanquesElevados: [...current.tanquesElevados, newTanque] }));
        }
    } else if (drawingMode === 'pipe' && clickedComponent) {
      if (!drawingPipeState.startComponent) {
        setDrawingPipeState({ startComponent: clickedComponent });
        mapRef.current?.highlightNode(clickedComponent.id, true);
        mapRef.current?.startGuideLine([clickedComponent.latitud, clickedComponent.longitud]);
      } else {
        const startComponent = drawingPipeState.startComponent;
        const endComponent = clickedComponent;

        if (startComponent.id === endComponent.id) return;
        
        const newPipe = createNewPipe(startComponent, endComponent, model.pipes);

        updateModel(current => {
            mapRef.current?.highlightNode(startComponent.id, false); 
            setDrawingPipeState({ startComponent: endComponent });
            mapRef.current?.highlightNode(endComponent.id, true);
            mapRef.current?.startGuideLine([endComponent.latitud, endComponent.longitud]);
            return { ...current, pipes: [...current.pipes, newPipe] };
        });
      }
    } else if (drawingMode === 'dual') {
        let startComponent: Connectable | null = drawingPipeState.startComponent;
        let endComponent: Connectable | null = clickedComponent;

        if (!startComponent) { // First click of a sequence
            if (endComponent) { // Clicked on existing component
                startComponent = endComponent;
            } else { // Clicked on empty space, create a node
                startComponent = await createNewNode(latlng, model);
                if (startComponent) {
                    updateModel(current => ({ ...current, nodes: [...current.nodes, startComponent as Node] }));
                }
            }
            if (startComponent) {
                setDrawingPipeState({ startComponent });
                mapRef.current?.highlightNode(startComponent.id, true);
                mapRef.current?.startGuideLine([startComponent.latitud, startComponent.longitud]);
            }
        } else { // Subsequent clicks
            if (endComponent && startComponent.id === endComponent.id) return; // Avoid self-connecting pipe

            if (!endComponent) { // If not clicking an existing component, create a new one (a node)
                endComponent = await createNewNode(latlng, model);
            }
            if (!endComponent) return; // Stop if node creation failed

            const newPipe = createNewPipe(startComponent, endComponent, model.pipes);
            
            updateModel(current => {
                mapRef.current?.highlightNode(startComponent!.id, false);
                setDrawingPipeState({ startComponent: endComponent });
                mapRef.current?.highlightNode(endComponent!.id, true);
                mapRef.current?.startGuideLine([endComponent!.latitud, endComponent!.longitud]);
                
                const modelHasEndNode = [...current.nodes, ...current.reservoirs, ...current.ptaps, ...current.bocatomas, ...current.captaciones, ...current.pozosProfundos, ...current.tanquesElevados].some(c => c.id === endComponent!.id);
                
                if (modelHasEndNode) {
                     return { ...current, pipes: [...current.pipes, newPipe] };
                } else {
                    // Assuming new un-clicked components are always nodes
                     return {
                        ...current,
                        nodes: [...current.nodes, endComponent as Node],
                        pipes: [...current.pipes, newPipe]
                    };
                }
            });
        }
    } else if (drawingMode === 'mesh') {
        if (meshState.status === 'settingStart') {
            setMeshState(prev => ({ ...prev, status: 'settingEnd', startPoint: latlng }));
            mapRef.current?.startGuideLine([latlng.lat, latlng.lng], { color: 'orange', dashArray: '10, 10' });
            toast({
                title: "Fijar Fin de Malla",
                description: "Haga clic en el mapa para establecer el punto final del primer lado de la malla.",
            });
        } else if (meshState.status === 'settingEnd' && meshState.startPoint) {
            setDrawingMode(null);
            mapRef.current?.stopGuideLine();
            await generateMesh(meshState.startPoint, latlng, meshState.params, model);
            setMeshState({ // Reset state
                status: 'configuring',
                params: { numVertical: 7, numHorizontal: 8, distance: 50 },
                startPoint: null,
            });
        }
    } else if (drawingMode === 'measure') {
        if (measureState.status === 'idle') {
            setMeasureState(prev => ({ ...prev, status: 'measuring', startPoint: latlng, distance: null }));
            mapRef.current?.startGuideLine([latlng.lat, latlng.lng], { color: 'red', dashArray: undefined });
        } else if (measureState.status === 'measuring' && measureState.startPoint) {
            const distanceInMeters = mapRef.current?.calculateDistance([measureState.startPoint.lat, measureState.startPoint.lng], [latlng.lat, latlng.lng]) || 0;
            mapRef.current?.stopGuideLine();
            mapRef.current?.drawMeasurementResultLine(measureState.startPoint, latlng);
            setMeasureState(prev => ({ ...prev, status: 'idle', startPoint: null, distance: distanceInMeters }));
        }
    } else if (drawingMode === 'viewer') {
        const newPoints = [...viewerBoxPoints, latlng];
        setViewerBoxPoints(newPoints);
        if (newPoints.length === 1) {
            mapRef.current?.startGuideLine([latlng.lat, latlng.lng], { color: 'orange', dashArray: '10, 10' });
            toast({ title: 'Visor: Punto Inicial Fijado', description: 'Seleccione el punto diagonal opuesto para definir el área de zoom.' });
        } else if (newPoints.length === 2) {
            handleFitBounds(newPoints[0], newPoints[1]);
        }
    } else if (drawingMode === 'delete-component') {
        if (clickedComponent) {
            if (clickedComponent.id.startsWith('N')) {
                updateModel(current => {
                    const nodeIdToDelete = clickedComponent.id;
                    const newNodes = current.nodes.filter(n => n.id !== nodeIdToDelete);
                    const newPipes = current.pipes.filter(p => p.startNodeId !== nodeIdToDelete && p.endNodeId !== nodeIdToDelete);
                    const pipesDeletedCount = current.pipes.length - newPipes.length;
                    toast({
                        title: "Componente Eliminado",
                        description: `Se eliminó el nudo ${nodeIdToDelete} y ${pipesDeletedCount} tuberías conectadas.`
                    });
                    return { ...current, nodes: newNodes, pipes: newPipes };
                });
            } else if (clickedComponent.id.startsWith('R')) {
                updateModel(current => {
                    const reservoirIdToDelete = clickedComponent.id;
                    const newReservoirs = current.reservoirs.filter(r => r.id !== reservoirIdToDelete);
                    const newPipes = current.pipes.filter(p => p.startNodeId !== reservoirIdToDelete && p.endNodeId !== reservoirIdToDelete);
                    const pipesDeletedCount = current.pipes.length - newPipes.length;
                    toast({
                        title: "Componente Eliminado",
                        description: `Se eliminó el reservorio ${reservoirIdToDelete} y ${pipesDeletedCount} tuberías conectadas.`
                    });
                    return { ...current, reservoirs: newReservoirs, pipes: newPipes };
                });
            }
        } else if (clickedPipe) {
            updateModel(current => {
                const newPipes = current.pipes.filter(p => p.id !== clickedPipe.id);
                toast({
                    title: "Componente Eliminado",
                    description: `Se eliminó la tubería ${clickedPipe.id}.`
                });
                return { ...current, pipes: newPipes };
            });
        } else if (clickedVertex) {
             updateModel(current => {
                const vertexIdToDelete = clickedVertex.id;
                // 1. Remove the vertex from the main vertices list
                const newVertices = current.vertices.filter(v => v.id !== vertexIdToDelete);

                // 2. Remove the vertex from any pipe that includes it and recalculate length
                const newPipes = current.pipes.map(pipe => {
                    if (pipe.vertexIds?.includes(vertexIdToDelete)) {
                        const newVertexIds = pipe.vertexIds.filter(id => id !== vertexIdToDelete);
                        
                        const allConnectables: Connectable[] = [...current.nodes, ...current.reservoirs];
                        const startNode = allConnectables.find(c => c.id === pipe.startNodeId);
                        const endNode = allConnectables.find(c => c.id === pipe.endNodeId);
                        if (!startNode || !endNode) return pipe;

                        const allPipeVertices = newVertexIds.map(vId => newVertices.find(v => v.id === vId)).filter((v): v is Vertex => !!v);

                        const allPoints = [
                            { lat: startNode.latitud, lng: startNode.longitud },
                            ...allPipeVertices.map(v => ({ lat: v.latitud, lng: v.longitud })),
                            { lat: endNode.latitud, lng: endNode.longitud }
                        ];

                        let newLength = 0;
                        for (let i = 0; i < allPoints.length - 1; i++) {
                            newLength += mapRef.current?.calculateDistance(
                                [allPoints[i].lat, allPoints[i].lng],
                                [allPoints[i + 1].lat, allPoints[i + 1].lng]
                            ) || 0;
                        }

                        return { ...pipe, vertexIds: newVertexIds, length: newLength };
                    }
                    return pipe;
                });
                
                toast({
                    title: "Componente Eliminado",
                    description: `Se eliminó el vértice ${vertexIdToDelete}.`
                });

                return { ...current, vertices: newVertices, pipes: newPipes };
            });
        }
    } else if (drawingMode === 'delete-selection') {
        setSelectionPolygon(prev => [...prev, latlng]);
    } else if (drawingMode === 'vertex' && clickedPipe) {
        if (clickedPipe.id.startsWith('T-')) {
            await handleInsertVertex(clickedPipe.id, latlng);
        } else {
            toast({
                title: 'Función no disponible',
                description: 'La inserción de vértices actualmente solo está soportada para tuberías de distribución.',
                variant: 'destructive',
            });
        }
    }
  };

  const handleMapDoubleClick = () => {
    if (drawingMode === 'delete-selection' && selectionPolygon.length > 2) {
      handleDeleteSelection();
    }
  };

  const handleNodeMove = async (nodeId: string, newLatLng: LatLng) => {
    toast({ title: `Moviendo ${nodeId}...`, description: "Obteniendo nueva cota del terreno." });
    const newElevation = await getElevation(newLatLng.lat, newLatLng.lng);
  
    updateModel(current => {
      const movedNode = current.nodes.find(n => n.id === nodeId);
      if (!movedNode) return current;
  
      // Check for fusion
      const FUSION_DISTANCE_THRESHOLD = 5; // meters
      const targetNode = current.nodes.find(n => {
        if (n.id === nodeId) return false;
        const distance = mapRef.current?.calculateDistance([newLatLng.lat, newLatLng.lng], [n.latitud, n.longitud]) || FUSION_DISTANCE_THRESHOLD + 1;
        return distance < FUSION_DISTANCE_THRESHOLD;
      });
  
      if (targetNode) {
        // Fusion logic
        const movedNodeNum = parseInt(movedNode.id.substring(1), 10);
        const targetNodeNum = parseInt(targetNode.id.substring(1), 10);
  
        const [nodeToKeep, nodeToRemove] = movedNodeNum < targetNodeNum
          ? [movedNode, targetNode]
          : [targetNode, movedNode];
  
        toast({
          title: "Fusión de Nudos",
          description: `El nudo ${nodeToRemove.id} se ha fusionado con ${nodeToKeep.id}.`,
        });
  
        // Re-assign pipes from removed node to the kept node
        const remappedPipes = current.pipes.map(pipe => {
          if (pipe.startNodeId === nodeToRemove.id) {
            return { ...pipe, startNodeId: nodeToKeep.id };
          }
          if (pipe.endNodeId === nodeToRemove.id) {
            return { ...pipe, endNodeId: nodeToKeep.id };
          }
          return pipe;
        });
  
        // Filter out self-looping pipes and duplicates
        const uniquePipeKeys = new Set<string>();
        const finalPipes = remappedPipes.filter(pipe => {
          if (pipe.startNodeId === pipe.endNodeId) {
            return false; // Remove self-looping pipe
          }
          // Create a canonical key for the pipe to detect duplicates regardless of direction
          const key = [pipe.startNodeId, pipe.endNodeId].sort().join('-');
          if (uniquePipeKeys.has(key)) {
            return false; // Remove duplicate pipe
          }
          uniquePipeKeys.add(key);
          return true;
        });
  
        return {
          ...current,
          nodes: current.nodes.filter(n => n.id !== nodeToRemove.id),
          pipes: finalPipes,
        };
  
      } else {
        // Standard move logic
        const newNodes = current.nodes.map(node =>
          node.id === nodeId
            ? {
                ...node,
                latitud: newLatLng.lat,
                longitud: newLatLng.lng,
                cotaTerreno: newElevation ?? node.cotaTerreno,
              }
            : node
        );
  
        toast({
          title: "Nudo Movido",
          description: `${nodeId} actualizado a la nueva posición con cota ${newElevation?.toFixed(2) ?? 'N/A'}m.`,
        });
  
        return { ...current, nodes: newNodes };
      }
    });
  };

  const handleVertexMove = async (vertexId: string, newLatLng: LatLng) => {
    toast({ title: `Moviendo Vértice ${vertexId}...`, description: "Obteniendo nueva cota." });
    const newElevation = await getElevation(newLatLng.lat, newLatLng.lng);

    updateModel(current => {
        // 1. Update the vertex's own properties
        const newVertices = current.vertices.map(v => 
            v.id === vertexId
                ? { ...v, latitud: newLatLng.lat, longitud: newLatLng.lng, cotaTerreno: newElevation }
                : v
        );

        // 2. Find affected pipes and update their length
        const newPipes = current.pipes.map(pipe => {
            if (pipe.vertexIds?.includes(vertexId)) {
                const allConnectables: Connectable[] = [...current.nodes, ...current.reservoirs];
                const startNode = allConnectables.find(c => c.id === pipe.startNodeId);
                const endNode = allConnectables.find(c => c.id === pipe.endNodeId);
                if (!startNode || !endNode) return pipe;

                const allPipeVertices = (pipe.vertexIds || []).map(vId => {
                    return newVertices.find(v => v.id === vId);
                }).filter((v): v is Vertex => v !== undefined);

                const allPoints = [
                    { lat: startNode.latitud, lng: startNode.longitud },
                    ...allPipeVertices.map(v => ({ lat: v.latitud, lng: v.longitud })),
                    { lat: endNode.latitud, lng: endNode.longitud }
                ];
                
                let newLength = 0;
                for (let i = 0; i < allPoints.length - 1; i++) {
                    newLength += mapRef.current?.calculateDistance(
                        [allPoints[i].lat, allPoints[i].lng],
                        [allPoints[i + 1].lat, allPoints[i + 1].lng]
                    ) || 0;
                }
                
                toast({
                    title: "Longitud de Tubería Actualizada",
                    description: `La longitud de ${pipe.id} ahora es ${newLength.toFixed(2)}m.`
                });

                return { ...pipe, length: newLength };
            }
            return pipe;
        });

        toast({
            title: "Vértice Movido",
            description: `${vertexId} actualizado a la nueva posición con cota ${newElevation?.toFixed(2) ?? 'N/A'}m.`
        });
        
        return {
            ...current,
            vertices: newVertices,
            pipes: newPipes
        };
    });
};


  const handleSave = () => {
    if (!projectData) {
      toast({
        title: "No hay proyecto para guardar",
        description: "Crea o abre un proyecto primero.",
        variant: "destructive",
      });
      return;
    }
  
    const projectStateToSave = {
      project: projectData,
      model: model, 
    };
  
    try {
      localStorage.setItem('hydrobim-project-data', JSON.stringify(projectStateToSave));
      toast({
        title: "Proyecto Guardado Localmente",
        description: `El proyecto "${projectData.nombre}" se guardó en el navegador.`,
      });
    } catch (error: any) {
      console.error("Failed to save project data to localStorage", error);
      const isQuotaError = error instanceof DOMException && (error.name === 'QuotaExceededError' || error.code === 22);
      toast({
        title: "Error al Guardar",
        description: isQuotaError 
          ? "No se pudo guardar el proyecto. El almacenamiento local está lleno."
          : "No se pudo guardar el proyecto localmente.",
        variant: "destructive",
      });
    }
  };
  
  const handleSaveProjectDialog = (data: ProjectData) => {
    setProjectData(data);
    setIsProjectDialogOpen(false);

    const projectStateToSave = {
      project: data,
      model: model,
    };
  
    try {
      localStorage.setItem('hydrobim-project-data', JSON.stringify(projectStateToSave));
      toast({
        title: "Datos de Proyecto Guardados",
        description: `La información del proyecto "${data.nombre}" ha sido actualizada y guardada.`,
      });
    } catch (error: any) {
      console.error("Failed to save project data to localStorage", error);
       const isQuotaError = error instanceof DOMException && (error.name === 'QuotaExceededError' || error.code === 22);
      toast({
        title: "Error al Guardar",
        description: isQuotaError 
          ? "No se pudo guardar el proyecto. El almacenamiento local está lleno."
          : "No se pudo guardar el proyecto localmente.",
        variant: "destructive",
      });
    }

    if (data.latitud && data.longitud) {
       const lat = parseFloat(data.latitud);
       const lng = parseFloat(data.longitud);
       if (!isNaN(lat) && !isNaN(lng)) {
           setTimeout(() => {
             mapRef.current?.setView([lat, lng], 15);
           }, 100);
           setMapCenter([lat, lng]);
           setMapZoom(15);
       }
    }
  };
  
  const handleOpenSaveAsDialog = () => {
    if (!projectData) {
      toast({
        title: "No hay datos que guardar",
        description: "Primero crea un nuevo proyecto o abre uno existente.",
        variant: "destructive",
      });
      return;
    }
    setIsSaveAsDialogOpen(true);
  };

  const executeSaveAs = (fileName: string) => {
    if (!projectData) return;

    const projectStateToSave = {
      project: projectData,
      model: model,
    };
    const jsonString = JSON.stringify(projectStateToSave, null, 2);
    const blob = new Blob([jsonString], { type: "application/json;charset=utf-8" });
    saveAs(blob, `${fileName}.json`);
    toast({
      title: "Proyecto Descargado",
      description: `El proyecto se ha guardado como "${fileName}.json".`,
    });
  };


  const handleOpenStatusDialog = () => {
    setIsStatusDialogOpen(true);
  };

  const handleOpenScopesDialog = () => {
    setIsScopesDialogOpen(true);
  };

  const handleUndo = () => {
    if (historyIndex > 0) {
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        setModel(history[newIndex]);
        toast({
            title: "Acción Deshecha",
            description: "Se ha revertido la última acción.",
        });
    }
  };

  const handleRenumber = () => {
    updateModel(current => {
      const { nodes, pipes } = current;

      const sortedNodes = [...nodes].sort((a, b) => {
        const numA = parseInt(a.id.substring(1)) || 0;
        const numB = parseInt(b.id.substring(1)) || 0;
        return numA - numB;
      });

      const nodeMap = new Map<string, string>();
      const newNodes = sortedNodes.map((node, index) => {
        const newId = `N${index + 1}`;
        nodeMap.set(node.id, newId);
        return { ...node, id: newId };
      });

      const sortedPipes = [...pipes].sort((a, b) => {
        const numA = parseInt(a.id.substring(2)) || 0;
        const numB = parseInt(b.id.substring(2)) || 0;
        return numA - numB;
      });
      
      const newPipes = sortedPipes.map((pipe, index) => {
        const newStartNodeId = nodeMap.get(pipe.startNodeId);
        const newEndNodeId = nodeMap.get(pipe.endNodeId);

        if (!newStartNodeId || !newEndNodeId) {
          console.warn(`Pipe ${pipe.id} references a non-existent node. Skipping.`);
          return null;
        }

        return {
          ...pipe,
          id: `T-${index + 1}`,
          startNodeId: newStartNodeId,
          endNodeId: newEndNodeId,
        };
      }).filter((p): p is Pipe => p !== null);

      toast({
        title: "Componentes Renumerados",
        description: `Se han renumerado ${newNodes.length} nudos y ${newPipes.length} tuberías.`,
      });

      return { ...current, nodes: newNodes, pipes: newPipes };
    });
  };

  const handlePurge = () => {
    updateModel(current => {
      let { nodes, pipes } = current;
      let nodesRemovedCount = 0;
      let pipesRemovedCount = 0;
      let duplicatesRemovedCount = 0;

      // 1. Remove duplicate nodes
      const uniqueNodes: Node[] = [];
      const nodeMap = new Map<string, string>(); // oldId -> newId
      const coordsMap = new Map<string, string>(); // 'lat,lng' -> nodeId

      nodes.forEach(node => {
        const coordKey = `${node.latitud.toFixed(6)},${node.longitud.toFixed(6)}`;
        if (coordsMap.has(coordKey)) {
          const existingNodeId = coordsMap.get(coordKey)!;
          nodeMap.set(node.id, existingNodeId);
          duplicatesRemovedCount++;
        } else {
          coordsMap.set(coordKey, node.id);
          nodeMap.set(node.id, node.id);
          uniqueNodes.push(node);
        }
      });
      
      if (duplicatesRemovedCount > 0) {
        pipes = pipes.map(pipe => ({
          ...pipe,
          startNodeId: nodeMap.get(pipe.startNodeId) || pipe.startNodeId,
          endNodeId: nodeMap.get(pipe.endNodeId) || pipe.endNodeId,
        }));
        nodes = uniqueNodes;
      }
      
      // 2. Remove isolated pipes (referencing non-existent nodes)
      const nodeIds = new Set(nodes.map(n => n.id));
      const initialPipesCount = pipes.length;
      pipes = pipes.filter(p => nodeIds.has(p.startNodeId) && nodeIds.has(p.endNodeId));
      pipesRemovedCount += initialPipesCount - pipes.length;

      // 3. Remove orphan nodes
      const connectedNodeIds = new Set();
      pipes.forEach(pipe => {
        connectedNodeIds.add(pipe.startNodeId);
        connectedNodeIds.add(pipe.endNodeId);
      });
      
      const initialNodesCount = nodes.length;
      nodes = nodes.filter(node => connectedNodeIds.has(node.id));
      nodesRemovedCount = initialNodesCount - nodes.length;

      toast({
        title: "Modelo Depurado",
        description: `Se eliminaron ${nodesRemovedCount} nudos huérfanos, ${duplicatesRemovedCount} nudos duplicados y ${pipesRemovedCount} tuberías aisladas.`,
      });

      return { ...current, nodes, pipes };
    });
  };

  const handleToolSelect = (tool: DrawingMode | 'project' | null) => {
    // Always cancel any ongoing drawing when a new tool is selected.
    cancelDrawing();
    // Explicitly clear start component state when changing tools
    if (drawingPipeState.startComponent) {
      mapRef.current?.highlightNode(drawingPipeState.startComponent.id, false);
      setDrawingPipeState({ startComponent: null });
    }

    if (tool === 'project') {
      handleOpenProjectDialog();
      setDrawingMode(null);
    } else if (tool === 'clean') {
      setIsCleanConfirmDialogOpen(true);
      setDrawingMode(null);
    } else if (tool === 'renumber') {
      setIsRenumberConfirmDialogOpen(true);
      setDrawingMode(null);
    } else if (tool === 'purge') {
        setIsPurgeConfirmDialogOpen(true);
        setDrawingMode(null);
    } else if (tool === 'undo') {
      handleUndo();
      setDrawingMode(null);
    } else if (tool === 'pump') {
        toast({
            title: "Herramienta no implementada",
            description: "Esta funcionalidad estará disponible en futuras versiones.",
        });
        setDrawingMode(null);
    } else if (tool === 'valve-purge' || tool === 'valve-air' || tool === 'valve-control' || tool === 'chamber-pumping' || tool === 'chamber-junction' || tool === 'chamber-pressure-break') {
        toast({
            title: "Herramienta no implementada",
            description: "Esta funcionalidad estará disponible en futuras versiones.",
        });
        setDrawingMode(null);
    }
    else {
      setDrawingMode(prev => {
        const newMode = prev === tool ? null : tool;
        // Any drawing/editing tool is active, hide tooltips. If no tool, show them.
        setHideNodeTooltips(newMode !== null);
        
        if (newMode === null) {
            cancelDrawing(); // Handles cleanup if the same tool is clicked to disable it
        }

        if (newMode === 'delete-selection') {
          toast({ title: 'Modo "Borrar por Selección"', description: 'Dibuja un polígono. Doble clic o presiona Enter para eliminar los elementos dentro.' });
        }
        if (newMode === 'viewer') {
            toast({ title: 'Modo "Visor"', description: 'Haga clic en un punto inicial para definir el área de zoom.' });
        }
        return newMode;
      });
    }
  };

  const handleImportKmlClick = () => {
    importKmlInputRef.current?.click();
  };

  const handleImportKmlSelected = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    toast({
      title: 'Importando archivo...',
      description: `Procesando ${file.name}.`,
    });

    try {
      updateModel(() => initialModel);
      await new Promise(resolve => setTimeout(resolve, 50)); 

      const { nodes: importedNodes, pipes: importedPipes, vertices: importedVertices } = await processKmlFile(file);
      
      updateModel(current => ({
        ...current,
        nodes: importedNodes,
        pipes: importedPipes,
        vertices: importedVertices,
      }));

      toast({
        title: 'Importación Exitosa',
        description: `Se importaron ${importedNodes.length} nudos, ${importedPipes.length} tuberías y ${importedVertices.length} vértices.`,
      });

      if (!projectData) {
         setProjectData({
            nombre: file.name.replace(/\.(kmz|kml)$/i, ''),
         });
      }

      if (importedNodes.length > 0) {
        const firstNode = importedNodes[0];
        const newCenter: LatLngExpression = [firstNode.latitud, firstNode.longitud];
        setMapCenter(newCenter);
        setMapZoom(16);
        mapRef.current?.setView(newCenter, 16);
      }

    } catch (error) {
      console.error('Error importing KML/KMZ:', error);
      toast({
        title: 'Error de Importación',
        description: (error as Error).message || 'No se pudo procesar el archivo.',
        variant: 'destructive',
      });
    } finally {
      if (event.target) {
        event.target.value = '';
      }
    }
  };

  const handleCsvImport = ({ file, options }: { file: File, options: Record<string, boolean>}) => {
      setIsCsvImportDialogOpen(false);
      toast({
          title: "Importando archivo CSV...",
          description: `Procesando ${file.name}.`,
      });

      Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          transformHeader: header => header.trim().toLowerCase(),
          complete: (results) => {
              if (results.errors.length) {
                  const firstError = results.errors[0];
                  toast({ title: "Error de Análisis CSV", description: `Error en la fila ${firstError.row}: ${firstError.message}`, variant: "destructive" });
                  return;
              }
              
              const findHeader = (aliases: string[]) => {
                  return results.meta.fields?.find(h => aliases.includes(h.toLowerCase()));
              }

              let importedNodes: Node[] = [];
              let importedPipes: Pipe[] = [];

              if (options.nodes) {
                  const idHeader = findHeader(['id', 'ids']);
                  const latHeader = findHeader(['lat', 'latitud']);
                  const lngHeader = findHeader(['lng', 'lon', 'longitud']);
                  const elevHeader = findHeader(['elevation', 'elevacion', 'cota', 'cotaterreno']);

                  if (!latHeader || !lngHeader) {
                      toast({ title: "Faltan columnas de nudos requeridas", description: "El archivo CSV de nudos debe contener cabeceras para latitud y longitud.", variant: "destructive"});
                  } else {
                      const existingNodeIds = new Set(model.nodes.map(n => n.id));
                      let nextNodeIdCounter = (model.nodes.length > 0 ? Math.max(...model.nodes.map(n => parseInt(n.id.substring(1)) || 0)) : 0) + 1;
                      
                      importedNodes = (results.data as any[]).map((row: any, index: number) => {
                          const lat = parseFloat(row[latHeader]);
                          const lng = parseFloat(row[lngHeader]);

                          if (isNaN(lat) || isNaN(lng)) {
                              console.warn(`Saltando fila de nudo ${index + 2} por coordenadas inválidas.`);
                              return null;
                          }

                          let id = idHeader && row[idHeader] ? String(row[idHeader]).trim() : '';
                          if (!id || existingNodeIds.has(id)) {
                              id = `N${nextNodeIdCounter++}`;
                          }
                          
                          const cota = elevHeader && row[elevHeader] ? parseFloat(row[elevHeader]) : null;

                          return {
                              id,
                              latitud: lat,
                              longitud: lng,
                              cotaTerreno: cota && !isNaN(cota) ? cota : null,
                              type: 'node',
                          };
                      }).filter((node): node is Node => node !== null && !existingNodeIds.has(node.id));
                  }
              }

              if (options.pipes) {
                  const idHeader = findHeader(['id', 'ids', 'pipeid']);
                  const startHeader = findHeader(['startnodeid', 'startnode', 'inicio']);
                  const endHeader = findHeader(['endnodeid', 'endnode', 'fin']);
                  const lengthHeader = findHeader(['length', 'longitud']);

                  if (!startHeader || !endHeader) {
                       toast({ title: "Faltan columnas de tuberías requeridas", description: "El archivo CSV de tuberías debe contener cabeceras para el nudo inicial y final.", variant: "destructive"});
                  } else {
                      const existingPipeIds = new Set(model.pipes.map(p => p.id));
                      let nextPipeIdCounter = (model.pipes.length > 0 ? Math.max(...model.pipes.map(p => parseInt(p.id.substring(2)) || 0)) : 0) + 1;

                      importedPipes = (results.data as any[]).map((row: any, index: number) => {
                          const startNodeId = row[startHeader];
                          const endNodeId = row[endHeader];
                          const length = lengthHeader && row[lengthHeader] ? parseFloat(row[lengthHeader]) : 0;
                          
                          if (!startNodeId || !endNodeId) {
                            console.warn(`Saltando fila de tubería ${index + 2} por falta de nudos.`);
                            return null;
                          }

                          let id = idHeader && row[idHeader] ? String(row[idHeader]).trim() : '';
                          if (!id || existingPipeIds.has(id)) {
                            id = `T-${nextPipeIdCounter++}`;
                          }

                          return {
                            id,
                            startNodeId: String(startNodeId),
                            endNodeId: String(endNodeId),
                            length: !isNaN(length) ? length : 0,
                            type: 'distribution',
                            vertexIds: []
                          };
                      }).filter((pipe): pipe is Pipe => pipe !== null && !existingPipeIds.has(pipe.id));
                  }
              }

              if (importedNodes.length > 0 || importedPipes.length > 0) {
                  updateModel((current) => ({
                      ...current,
                      nodes: [...current.nodes, ...importedNodes],
                      pipes: [...current.pipes, ...importedPipes],
                  }));

                  toast({
                      title: "Importación CSV Exitosa",
                      description: `Se importaron ${importedNodes.length} nudos y ${importedPipes.length} tuberías.`
                  });

                  if (importedNodes.length > 0 && model.nodes.length === 0) {
                      const firstNode = importedNodes[0];
                      const newCenter: LatLngExpression = [firstNode.latitud, firstNode.longitud];
                      setMapCenter(newCenter);
                      setMapZoom(16);
                      mapRef.current?.setView(newCenter, 16);
                  }
              } else {
                  toast({
                      title: "Importación CSV",
                      description: "No se encontraron nuevos elementos para importar o los tipos de componente no fueron seleccionados.",
                  });
              }
          },
          error: (error: Error) => {
             console.error('Error importing CSV:', error);
              toast({
                  title: 'Error de Importación CSV',
                  description: error.message || 'No se pudo procesar el archivo.',
                  variant: 'destructive',
              });
          }
      });
  };

  const getProjectInitials = (name?: string): string => {
    if (!name) return 'PROY';
    return name.split(' ').map(word => word.charAt(0)).join('').toUpperCase() || 'PROY';
  }

  const handleExecuteExport = async (options: { nodes: boolean; pipes: boolean }) => {
    setIsCsvExportDialogOpen(false);
    
    if (!options.nodes && !options.pipes) {
        toast({
            title: "Exportación Cancelada",
            description: "No se seleccionó ningún tipo de componente para exportar.",
            variant: "destructive",
        });
        return;
    }

    const projectInitials = getProjectInitials(projectData?.nombre);

    const zip = new JSZip();
    let filesGenerated = 0;

    if (options.nodes && nodes.length > 0) {
        const nodeData = nodes.map(n => ({
            id: n.id,
            lat: n.latitud,
            lng: n.longitud,
            cotaTerreno: n.cotaTerreno ?? ''
        }));
        const csvContent = Papa.unparse(nodeData, { header: true });
        
        if (options.pipes && pipes.length > 0) {
            zip.file(`Nudos_${projectInitials}.csv`, csvContent);
        } else {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, `Nudos_${projectInitials}.csv`);
        }
        filesGenerated++;
    }

    if (options.pipes && pipes.length > 0) {
        const distributionPipes = pipes.filter(p => p.type === 'distribution');
        const pipeData = distributionPipes.map(p => ({
            id: p.id,
            startNodeId: p.startNodeId,
            endNodeId: p.endNodeId,
            length: p.length.toFixed(2),
        }));
        const csvContent = Papa.unparse(pipeData, { header: true });
        
        if (options.nodes && nodes.length > 0) {
             zip.file(`Tuberias_${projectInitials}.csv`, csvContent);
        } else {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, `Tuberias_${projectInitials}.csv`);
        }
        filesGenerated++;
    }

    if (options.nodes && options.pipes && nodes.length > 0 && pipes.length > 0) {
        try {
            const zipBlob = await zip.generateAsync({ type: "blob" });
            saveAs(zipBlob, `${projectInitials}_export.zip`);
            toast({
                title: "Exportación a ZIP Exitosa",
                description: `Se han exportado nudos y tuberías a ${projectInitials}_export.zip.`
            });
        } catch (error) {
             toast({
                title: "Error al crear ZIP",
                description: "No se pudo generar el archivo comprimido.",
                variant: "destructive",
            });
        }
        return;
    }
    
    if (filesGenerated === 0) {
         toast({
            title: "No hay datos para exportar",
            description: "No existen elementos de los tipos seleccionados en el modelo.",
            variant: "destructive",
        });
        return;
    }
    
    toast({
        title: "Exportación a CSV Exitosa",
        description: `Se ha exportado el archivo seleccionado.`
    });
  };

  const handleExportToKml = () => {
    if (!projectData) {
      toast({
        title: "No hay proyecto para exportar",
        description: "Crea o abre un proyecto primero.",
        variant: "destructive",
      });
      return;
    }

    if (nodes.length === 0 && pipes.length === 0) {
      toast({
        title: "No hay datos para exportar",
        description: "El modelo está vacío.",
        variant: "destructive",
      });
      return;
    }

    try {
        const kmlContent = generateKml(nodes, pipes, vertices, projectData.nombre || 'HydroBIM Project');
        const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml;charset=utf-8' });
        const fileName = `${projectData.nombre.replace(/\s+/g, '_') || 'hydrobim-project'}.kml`;
        saveAs(blob, fileName);

        toast({
          title: "Exportación a KML Exitosa",
          description: `Se ha exportado el proyecto a ${fileName}.`
        });
    } catch(error) {
        console.error("Failed to generate KML:", error);
        toast({
            title: "Error al Exportar KML",
            description: "No se pudo generar el archivo KML.",
            variant: "destructive",
        });
    }
  };

  const handleExit = () => {
    setIsExitConfirmDialogOpen(true);
  };
  
  const handleOpenProjectClick = () => {
    openProjectFileInputRef.current?.click();
  };

  const handleOpenProjectFile = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
  
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const text = e.target?.result;
        if (typeof text !== 'string') {
          throw new Error('Error al leer el archivo.');
        }
        const data = JSON.parse(text);
  
        // Simplified and direct check
        if (data && data.project && data.model && Array.isArray(data.model.nodes) && Array.isArray(data.model.pipes)) {
          setProjectData(data.project);
          
          const loadedModel: HydroModel = {
            ...initialModel,
            ...data.model,
            pipes: (data.model.pipes || []).map((p: Pipe) => ({ ...p, vertexIds: p.vertexIds || [] })),
            vertices: data.model.vertices || [],
            reservoirs: (data.model.reservoirs || []).map((r: any) => ({ ...r, horasConsumo: r.horasConsumo || 0, horasLlenado: r.horasLlenado || 0, volumenReserva: r.volumenReserva || 0, volumenContraIncendio: r.volumenContraIncendio || 0 })),
            ptaps: data.model.ptaps || [],
            bocatomas: data.model.bocatomas || [],
            captaciones: data.model.captaciones || [],
            pozosProfundos: data.model.pozosProfundos || [],
            tanquesElevados: data.model.tanquesElevados || [],
          };
          setModel(loadedModel);
          setHistory([loadedModel]);
          setHistoryIndex(0);
  
          if (data.project.latitud && data.project.longitud) {
            const lat = parseFloat(data.project.latitud);
            const lng = parseFloat(data.project.longitud);
            if (!isNaN(lat) && !isNaN(lng)) {
              const newCenter: LatLngExpression = [lat, lng];
              setMapCenter(newCenter);
              setMapZoom(15);
              mapRef.current?.setView(newCenter, 15);
            }
          }
          toast({
            title: 'Proyecto Abierto Exitosamente',
            description: `Se ha cargado el proyecto "${data.project.nombre}".`,
          });
        } else {
          throw new Error("El archivo no tiene el formato de proyecto HydroBIM válido.");
        }
      } catch (error) {
        console.error('Failed to parse project file:', error);
        toast({
          title: 'Error al Abrir Proyecto',
          description: (error as Error).message || 'El archivo está corrupto o no es válido.',
          variant: 'destructive',
        });
      } finally {
        if (event.target) {
          event.target.value = '';
        }
      }
    };
    reader.readAsText(file);
  };

  const handleSetMeshParams = (params: MeshParams) => {
    setMeshState(prev => ({ ...prev, params }));
  }

  const handleFixAndModelMesh = () => {
    setDrawingMode('mesh');
    setMeshState(prev => ({ ...prev, status: 'settingStart' }));
    toast({
        title: "Fijar Inicio de Malla",
        description: "Haga clic en el mapa para establecer el punto inicial del primer lado de la malla.",
    });
  };

  const handleFitBounds = (point1: LatLng, point2: LatLng) => {
    mapRef.current?.fitBounds(point1, point2);
    setDrawingMode(null);
    setViewerBoxPoints([]);
    mapRef.current?.stopGuideLine();
    toast({ title: 'Vista Ajustada', description: 'El mapa se ha centrado en el área seleccionada.' });
  }

  // Measurement Tool Handlers
  const handleMeasureAgain = () => {
    mapRef.current?.clearMeasurementResultLine();
    mapRef.current?.stopGuideLine();
    setMeasureState(prev => ({ ...prev, unit: 'm', distance: null, startPoint: null }));
    toast({
        title: "Medición Reiniciada",
        description: "Haga clic en el mapa para iniciar una nueva medición.",
    });
  };

  const handleMeasureExit = () => {
    mapRef.current?.clearMeasurementResultLine();
    mapRef.current?.stopGuideLine();
    setMeasureState({ status: 'idle', startPoint: null, distance: null, unit: 'm' });
    setDrawingMode(null);
  };

  const handleUnitChange = (unit: MeasureUnit) => {
    setMeasureState(prev => ({ ...prev, unit }));
  };

  return (
    <main className="flex flex-col h-screen">
      <header className="flex h-14 items-center border-b px-4 flex-shrink-0 relative z-20 bg-background">
        <h1 className="text-xl font-bold">HydroBIM</h1>
        <Menubar className="ml-6 border-none shadow-none">
          <MenubarMenu>
            <MenubarTrigger>Archivo</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={handleNewProject}>Nuevo</MenubarItem>
              <MenubarItem onSelect={handleOpenProjectClick}>Abrir</MenubarItem>
              <MenubarSeparator />
              <MenubarItem onSelect={handleSave}>Guardar</MenubarItem>
              <MenubarItem onSelect={handleOpenSaveAsDialog}>Guardar Como</MenubarItem>
              <MenubarSeparator />
              <MenubarSub>
                <MenubarSubTrigger>Importar</MenubarSubTrigger>
                <MenubarSubContent>
                  <MenubarItem onSelect={handleImportKmlClick}>Archivos KMZ/KML</MenubarItem>
                  <MenubarItem onSelect={() => setIsCsvImportDialogOpen(true)}>Archivos CSV</MenubarItem>
                </MenubarSubContent>
              </MenubarSub>
              <MenubarSub>
                <MenubarSubTrigger>Exportar</MenubarSubTrigger>
                <MenubarSubContent>
                  <MenubarItem onSelect={handleExportToKml}>Archivos KML</MenubarItem>
                  <MenubarItem onSelect={() => setIsCsvExportDialogOpen(true)}>Archivos CSV</MenubarItem>
                </MenubarSubContent>
              </MenubarSub>
              <MenubarSeparator />
              <MenubarItem onSelect={handleExit}>Salir</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Datos</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={handleOpenProjectDialog}>Proyecto</MenubarItem>
              <MenubarItem>Parámetros de Diseño</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Mapa GIS</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={() => setMapLayer('streets')}>Calles</MenubarItem>
              <MenubarItem onSelect={() => setMapLayer('topo')}>Topografía</MenubarItem>
              <MenubarItem onSelect={() => setMapLayer('satellite')}>Satelital</MenubarItem>
              <MenubarItem onSelect={() => setMapLayer('neutral')}>Neutral</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Modelado</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={toggleModelingToolbar}>Herramienta de Modelado</MenubarItem>
              <MenubarItem>Topografía</MenubarItem>
              <MenubarItem disabled>Visor 3D (Deshabilitado)</MenubarItem>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Sistema o Red</MenubarTrigger>
            <MenubarContent>
              <MenubarSub>
                <MenubarSubTrigger>Datos del Modelado</MenubarSubTrigger>
                <MenubarSubContent>
                  <MenubarItem onSelect={() => setIsNodesDialogOpen(true)}>Nudos</MenubarItem>
                  <MenubarItem onSelect={() => setIsVerticesDialogOpen(true)}>Vértices</MenubarItem>
                  <MenubarItem onSelect={() => setIsPipesDialogOpen(true)}>Tuberías de Distribución</MenubarItem>
                  <MenubarItem>Tuberías de Aducción</MenubarItem>
                  <MenubarItem>Tuberías de Conducción</MenubarItem>
                  <MenubarItem onSelect={() => setIsReservoirsDialogOpen(true)}>Reservorios</MenubarItem>
                  <MenubarItem onSelect={() => setIsPtapsDialogOpen(true)}>PTAPs</MenubarItem>
                  <MenubarItem onSelect={() => setIsBocatomasDialogOpen(true)}>Bocatomas</MenubarItem>
                  <MenubarItem onSelect={() => setIsCaptacionesDialogOpen(true)}>Captaciones</MenubarItem>
                  <MenubarItem onSelect={() => setIsPozosProfundosDialogOpen(true)}>Pozos Profundos</MenubarItem>
                  <MenubarItem onSelect={() => setIsTanquesElevadosDialogOpen(true)}>Tanques Elevados</MenubarItem>
                </MenubarSubContent>
              </MenubarSub>
            </MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Simulación</MenubarTrigger>
            <MenubarContent></MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Configuración</MenubarTrigger>
            <MenubarContent></MenubarContent>
          </MenubarMenu>
          <MenubarMenu>
            <MenubarTrigger>Ayuda</MenubarTrigger>
            <MenubarContent>
              <MenubarItem onSelect={handleOpenScopesDialog}>
                Alcances del Aplicativo
              </MenubarItem>
              <MenubarItem onSelect={handleOpenStatusDialog}>
                Estado de Funcionalidad
              </MenubarItem>
            </MenubarContent>
          </MenubarMenu>
        </Menubar>
      </header>
      <div className="flex-grow relative z-10">
        <input
            type="file"
            accept=".kml,.kmz"
            style={{ display: 'none' }}
            ref={importKmlInputRef}
            onChange={handleImportKmlSelected}
        />
        <input
            type="file"
            accept=".json"
            style={{ display: 'none' }}
            ref={openProjectFileInputRef}
            onChange={handleOpenProjectFile}
        />
        <MapComponent 
          ref={mapRef} 
          onMapClick={handleMapClick}
          onNodeMove={handleNodeMove}
          onVertexMove={handleVertexMove}
          onMapDoubleClick={handleMapDoubleClick}
          drawingMode={drawingMode}
          initialCenter={mapCenter}
          initialZoom={mapZoom}
          nodes={nodes}
          pipes={pipes}
          vertices={vertices}
          reservoirs={reservoirs}
          ptaps={ptaps}
          bocatomas={bocatomas}
          captaciones={captaciones}
          pozosProfundos={pozosProfundos}
          tanquesElevados={tanquesElevados}
          hideNodeTooltips={hideNodeTooltips}
          selectionPolygon={selectionPolygon}
        />
        {showModelingToolbar && <ModelingToolbar onToolSelect={handleToolSelect} activeTool={drawingMode} canUndo={historyIndex > 0} />}
         {drawingMode === 'mesh' && meshState.status === 'configuring' && (
            <MeshControlCard 
                onParamsChange={handleSetMeshParams}
                onFixAndModel={handleFixAndModelMesh}
                initialParams={meshState.params}
            />
        )}
        {drawingMode === 'measure' && (
            <MeasureControlCard 
                distance={measureState.distance}
                unit={measureState.unit}
                onUnitChange={handleUnitChange}
                onMeasureAgain={handleMeasureAgain}
                onExit={handleMeasureExit}
            />
        )}
        <div className="absolute bottom-4 left-4 z-[999] p-2 bg-background/80 backdrop-blur-sm rounded-md shadow-md text-xs">
            <div>Autor: Ing. Rulli Llancari Anyaipoma</div>
            <div>BIM Proyectos Integrados SAC</div>
        </div>
      </div>
      <ProjectDialog 
        isOpen={isProjectDialogOpen} 
        onOpenChange={setIsProjectDialogOpen}
        onSave={handleSaveProjectDialog}
        initialData={projectData}
      />
       <SaveAsDialog
        isOpen={isSaveAsDialogOpen}
        onOpenChange={setIsSaveAsDialogOpen}
        onSave={executeSaveAs}
        defaultFileName={projectData?.nombre ? projectData.nombre.replace(/\s+/g, '_') : 'hydrobim-project'}
      />
      <StatusDialog isOpen={isStatusDialogOpen} onOpenChange={setIsStatusDialogOpen} />
      <ScopesDialog isOpen={isScopesDialogOpen} onOpenChange={setIsScopesDialogOpen} />
      <NodesDialog isOpen={isNodesDialogOpen} onOpenChange={setIsNodesDialogOpen} nodes={nodes} />
      <PipesDialog isOpen={isPipesDialogOpen} onOpenChange={setIsPipesDialogOpen} pipes={pipes} />
      <VerticesDialog isOpen={isVerticesDialogOpen} onOpenChange={setIsVerticesDialogOpen} vertices={vertices} />
      <ReservoirsDialog isOpen={isReservoirsDialogOpen} onOpenChange={setIsReservoirsDialogOpen} reservoirs={reservoirs} />
      <PTAPsDialog isOpen={isPtapsDialogOpen} onOpenChange={setIsPtapsDialogOpen} ptaps={ptaps} />
      <BocatomasDialog isOpen={isBocatomasDialogOpen} onOpenChange={setIsBocatomasDialogOpen} bocatomas={bocatomas} />
      <CaptacionesDialog isOpen={isCaptacionesDialogOpen} onOpenChange={setIsCaptacionesDialogOpen} captaciones={captaciones} />
      <PozosProfundosDialog isOpen={isPozosProfundosDialogOpen} onOpenChange={setIsPozosProfundosDialogOpen} pozosProfundos={pozosProfundos} />
      <TanquesElevadosDialog isOpen={isTanquesElevadosDialogOpen} onOpenChange={setIsTanquesElevadosDialogOpen} tanquesElevados={tanquesElevados} />
      <CsvImportDialog isOpen={isCsvImportDialogOpen} onOpenChange={setIsCsvImportDialogOpen} onImport={handleCsvImport} />
      <CsvExportDialog
        isOpen={isCsvExportDialogOpen}
        onOpenChange={setIsCsvExportDialogOpen}
        onExport={handleExecuteExport}
        hasNodes={nodes.length > 0}
        hasPipes={pipes.length > 0}
      />
      
      <AlertDialog open={isCleanConfirmDialogOpen} onOpenChange={setIsCleanConfirmDialogOpen}>
        <AlertDialogContent>
            <AlertDialogHeader>
                <AlertDialogTitle>¿Está seguro de limpiar el lienzo?</AlertDialogTitle>
                <AlertDialogDescription>
                    Esta acción es irreversible y borrará todos los nudos y tuberías del proyecto actual.
                </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
                <AlertDialogCancel>Cancelar</AlertDialogCancel>
                <AlertDialogAction onClick={() => { handleClean(); setIsCleanConfirmDialogOpen(false); }}>
                    Sí, limpiar lienzo
                </AlertDialogAction>
            </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <AlertDialog open={isRenumberConfirmDialogOpen} onOpenChange={setIsRenumberConfirmDialogOpen}>
        <AlertDialogContent>
            <AlertDialogHeader>
                <AlertDialogTitle>¿Está seguro de renumerar los componentes?</AlertDialogTitle>
                <AlertDialogDescription>
                    Esta acción reasignará los IDs de todos los nudos y tuberías de forma secuencial, empezando desde 1.
                </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
                <AlertDialogCancel>Cancelar</AlertDialogCancel>
                <AlertDialogAction onClick={() => { handleRenumber(); setIsRenumberConfirmDialogOpen(false); }}>
                    Sí, renumerar
                </AlertDialogAction>
            </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <AlertDialog open={isPurgeConfirmDialogOpen} onOpenChange={setIsPurgeConfirmDialogOpen}>
        <AlertDialogContent>
            <AlertDialogHeader>
                <AlertDialogTitle>¿Está seguro de depurar el modelo?</AlertDialogTitle>
                <AlertDialogDescription>
                    Esta acción eliminará nudos duplicados, nudos huérfanos (no conectados a ninguna tubería) y tuberías que hagan referencia a nudos inexistentes.
                </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
                <AlertDialogCancel>Cancelar</AlertDialogCancel>
                <AlertDialogAction onClick={() => { handlePurge(); setIsPurgeConfirmDialogOpen(false); }}>
                    Sí, depurar
                </AlertDialogAction>
            </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

       <AlertDialog open={isExitConfirmDialogOpen} onOpenChange={setIsExitConfirmDialogOpen}>
        <AlertDialogContent>
            <AlertDialogHeader>
                <AlertDialogTitle>¿Está seguro de que desea salir?</AlertDialogTitle>
                <AlertDialogDescription>
                    Asegúrese de haber guardado su trabajo antes de salir. Cualquier cambio no guardado se perderá.
                </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
                <AlertDialogCancel>No, quedarme</AlertDialogCancel>
                <AlertDialogAction onClick={() => { setIsExitConfirmDialogOpen(false); window.close(); }}>
                    Sí, salir
                </AlertDialogAction>
            </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </main>
  );
}
